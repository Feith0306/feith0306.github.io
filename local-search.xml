<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>凸优化学习系列 - 1. 基本概念</title>
    <link href="/2026/01/26/03=Convex_Optimization/CVX-1/"/>
    <url>/2026/01/26/03=Convex_Optimization/CVX-1/</url>
    
    <content type="html"><![CDATA[<p>从【<a href="https://www.stat.cmu.edu/~ryantibs/convexopt/">CMU 课程，10-725, 2019</a>】出发，这一系列的文档用于整理/讨论凸优化问题相关的基本概念和重要求解方法，主要包括（暂定）：</p><ul><li>凸优化问题的重要概念（什么是凸优化问题，为什么要做凸优化）</li><li>一阶求解方法<details><ul><li>梯度下降法（Gradient Descent）</li><li>子梯度方法（Subgradient Method）</li><li>近端梯度下降法（Proximal Gradient Method）</li><li>随机梯度下降法（Stochastic Gradient Descent）</li></ul></details></li><li>对偶理论和最优理论<details><ul><li>线性/非线性对偶理论</li><li>KKT 条件（Karush-Kuhn-Tucker 条件）</li><li>对偶性应用</li></ul></details></li><li>二阶求解方法<details><ul><li>牛顿法</li><li>屏障法（Barrier Method）</li><li>原始对偶内点法（Primal-Dual Interior Point Method）</li><li>类牛顿法（Quasi-Newton Method）</li></ul></details></li><li>凸优化问题的前沿理论<details><ul><li>数值线性代数（Numerical linear algebra）</li><li>坐标下降法（Coordinate descent）</li><li>对偶分解（Dual decomposition）</li><li>乘子交替方向法（Alternating direction method of multipliers, ADMM）</li><li>条件梯度法（Frank-Wolfe method）</li><li>现代随机方法（Modern stochastic methods）</li><li>一阶非凸优化（First-order nonconvex optimization）</li><li>Bregman 近端方法（Bregman proximal methods）</li></ul></details></li></ul><p><strong>这个文档简要介绍凸优化问题的重要概念。</strong></p><h1 id="基础预备知识">1、基础预备知识</h1><h2 id="凸集compact-set">1.1 凸集（Compact set）</h2><div class="note note-success">            <p><strong>定义 1</strong>：对任意 <span class="math inline">\(x, y \in C \subseteq \mathbb{R}^n\)</span> 和任意 <span class="math inline">\(\lambda \in [0,1]\)</span>，有 <span class="math display">\[\begin{align}\lambda x + (1-\lambda) y \in C\end{align}\]</span> 则称集合 <span class="math inline">\(C\)</span> 是凸集。</p>          </div><p>从几何角度来看，凸集的定义可以理解为：对于集合 <span class="math inline">\(C\)</span> 中的任意两点 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，连接 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的<strong>线段</strong>也完全包含在集合 <span class="math inline">\(C\)</span> 中。</p><h2 id="仿射集affine-set">1.2 仿射集（Affine set）</h2><div class="note note-success">            <p><strong>定义 2</strong>：对任意 <span class="math inline">\(x, y \in A \subseteq \mathbb{R}^n\)</span> 和任意 <span class="math inline">\(\theta \in \mathbb{R}\)</span>，有 <span class="math display">\[\begin{align}\theta x + (1-\theta) y \in A\end{align}\]</span> 则称集合 <span class="math inline">\(A\)</span> 是仿射集。</p>          </div><p>从几何角度来看，仿射集的定义可以理解为：对于集合 <span class="math inline">\(A\)</span> 中的任意两点 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，连接 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的<strong>直线</strong>也完全包含在集合 <span class="math inline">\(A\)</span> 中。</p><h2 id="凸函数convex-function">1.3 凸函数（Convex function）</h2><div class="note note-success">            <p><strong>定义 3</strong>：设 <span class="math inline">\(C \subseteq \mathbb{R}^n\)</span> 是一个凸集，函数 <span class="math inline">\(f: C \to \mathbb{R}\)</span> 称为凸函数，如果对任意 <span class="math inline">\(x, y \in C\)</span> 和任意 <span class="math inline">\(\lambda \in [0,1]\)</span>，有 <span class="math display">\[\begin{align}f(\lambda x + (1-\lambda) y) \leq \lambda f(x) + (1-\lambda) f(y)\end{align}\]</span></p>          </div><p>从几何角度来看，凸函数的定义可以理解为：对于函数 <span class="math inline">\(f\)</span> 的任意两点 <span class="math inline">\((x, f(x))\)</span> 和 <span class="math inline">\((y, f(y))\)</span>，连接这两点的<strong>线段</strong>位于函数图像的<strong>上方</strong>。</p><ul><li>严格凸函数（strictly convex）：<span class="math inline">\(f(\lambda x + (1-\lambda) y) &lt; \lambda f(x) + (1-\lambda) f(y)\)</span>；</li><li><span class="math inline">\(m\)</span>- 强凸函数（strongly convex）：存在常数 <span class="math inline">\(m&gt;0\)</span>，使得 <span class="math inline">\(f(x) - \frac{m}{2}\|x\|_2^2\)</span> 是凸函数。</li></ul><blockquote><p>强凸 <span class="math inline">\(\Rightarrow\)</span> 严格凸 <span class="math inline">\(\Rightarrow\)</span> 凸。</p></blockquote><h2 id="仿射函数affine-function">1.4 仿射函数（Affine function）</h2><div class="note note-success">            <p><strong>定义 4</strong>：函数 <span class="math inline">\(f: \mathbb{R}^n \to \mathbb{R}\)</span> 称为仿射函数，如果存在向量 <span class="math inline">\(a \in \mathbb{R}^n\)</span> 和标量 <span class="math inline">\(b \in \mathbb{R}\)</span>，使得对任意 <span class="math inline">\(x \in \mathbb{R}^n\)</span> 和 <span class="math inline">\(\theta \in \mathbb{R}\)</span>，有 <span class="math display">\[\begin{align}f\bigl(\theta x + (1-\theta)y\bigr) = \theta f(x) + (1-\theta)f(y)\end{align}\]</span></p>          </div><p>从几何角度来看，仿射函数的定义可以理解为：对于函数 <span class="math inline">\(f\)</span> 的任意两点 <span class="math inline">\((x, f(x))\)</span> 和 <span class="math inline">\((y, f(y))\)</span>，连接这两点的<strong>直线</strong>位于函数图像上。常见的仿射函数形式为 <span class="math inline">\(f(x) = a^T x + b\)</span>。</p><h1 id="凸优化问题">2、凸优化问题</h1><h1 id="为什么要做凸优化why">2.1、为什么要做凸优化（Why）</h1><p>为什么不能做非凸优化？ 最小化问题为什么不能用其他理论结构？</p><h1 id="凸优化问题的标准形式what">2.2、凸优化问题的标准形式（What）</h1><div class="note note-info">            <p>典型的凸优化问题可以表示为以下标准形式： <span class="math display">\[\begin{align}    \min_{x \in D} \quad &amp; f(x) \\    \text{subject to} \quad &amp;     \begin{cases}    g_i(x) \le 0, \quad i = 1, \cdots, m \\    h_j(x) = 0, \quad j = 1, \cdots, p    \end{cases}\end{align}\]</span></p>          </div><p>其中：</p><ul><li><span class="math inline">\(D\)</span> 为满足约束条件且 <span class="math inline">\(f,g_i,h_j\)</span> 有意义的集合，称为<strong>可行域</strong>；</li><li>目标函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 是<strong>凸函数（优化目标）</strong>；</li><li>变量 <span class="math inline">\(x \in \mathbb{R}^n\)</span> 是需要优化的参数（<strong>决策变量</strong>）；</li><li>等式约束函数 <span class="math inline">\(h_i: D \to \mathbb{R}\)</span> 是仿射函数（<strong>等式约束</strong>）；</li><li>不等式约束函数 <span class="math inline">\(g_j: D \to \mathbb{R}\)</span> 是凸函数（<strong>不等式约束</strong>）。</li></ul><div class="note note-warning">            <p><strong>问题一：为什么不等式约束 <span class="math inline">\(g_i\)</span> 是凸函数？</strong></p><ul><li>不等式约束 <span class="math inline">\(g_i(x) \le 0\)</span>：<strong><code>为了保证可行域是凸集</code></strong>，必须要求 <span class="math inline">\(g_i\)</span> 是凸函数；因为凸函数的<strong>次水平集</strong>（sublevel set）<span class="math inline">\(\{x | g_i(x) \le 0\}\)</span> 是凸集，证明如下：<ul><li>对任意 <span class="math inline">\(x, y\)</span> 满足 <span class="math inline">\(g_i(x) \le 0\)</span> 和 <span class="math inline">\(g_i(y) \le 0\)</span>，以及任意 <span class="math inline">\(\lambda \in [0,1]\)</span>，有 <span class="math display">\[\begin{align}g_i(\lambda x + (1-\lambda) y) &amp;\leq \lambda g_i(x) + (1-\lambda) g_i(y) \quad (\text{因为 } g_i \text{ 是凸函数}) \\&amp;\leq \lambda \cdot 0 + (1-\lambda) \cdot 0 = 0\end{align}\]</span></li><li>因此，<span class="math inline">\(\{x | g_i(x) \le 0\}\)</span> 是凸集。</li></ul></li></ul><p><strong>问题二：为什么等式约束 <span class="math inline">\(h_j\)</span> 是仿射函数？</strong></p><ul><li>等式约束 <span class="math inline">\(h_j(x) = 0\)</span>：<strong><code>为了保证可行域是凸集</code></strong>，必须要求 <span class="math inline">\(h_j\)</span> 是仿射函数；因为仿射函数的<strong>零水平集</strong>（zero level set）<span class="math inline">\(\{x | h_j(x) = 0\}\)</span> 是凸集，证明如下：<ul><li>对任意 <span class="math inline">\(x, y\)</span> 满足 <span class="math inline">\(h_j(x) = 0\)</span> 和 <span class="math inline">\(h_j(y) = 0\)</span>，以及任意 <span class="math inline">\(\theta \in \mathbb{R}\)</span>，有 <span class="math display">\[\begin{align}h_j(\theta x + (1-\theta) y) &amp;= \theta h_j(x) + (1-\theta) h_j(y) \quad (\text{因为 } h_j \text{ 是仿射函数}) \\&amp;= \theta \cdot 0 + (1-\theta) \cdot 0 = 0\end{align}\]</span></li><li>因此，<span class="math inline">\(\{x | h_j(x) = 0\}\)</span> 是凸集。</li><li>另一方面。如果 <span class="math inline">\(h_j(x)\)</span> 不是仿射函数，如 <span class="math inline">\(h(x) = x^2 - 1\)</span>，<span class="math inline">\(h(x) = 0\)</span> 的解集为 <span class="math inline">\(\{-1, 1\}\)</span>，显然不是凸集。</li></ul></li></ul><p><strong>问题三：为什么可行域必须是凸集？</strong></p><p><strong>问题四：为什么目标函数必须是凸的？</strong></p>          </div><h1 id="凸优化问题解的存在性和唯一性">2.3、凸优化问题解的存在性和唯一性</h1><h2 id="什么叫凸优化问题有解">2.3.1、什么叫凸优化问题有解？</h2><p>针对凸优化问题</p><div class="note note-info">            <p><strong>定义 5</strong>：设 <span class="math inline">\(D \subseteq \mathbb{R}^n\)</span> 是非空凸集，函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 是凸函数。若存在 <span class="math inline">\(x^\star \in D\)</span> 使得 <span class="math display">\[\begin{align}f(x^\star) = \min_{x \in D} f(x),\end{align}\]</span> 则称 <span class="math inline">\(x^\star\)</span> 是凸优化问题的一个<strong>最优解</strong>，且称该凸优化问题<strong>有解</strong>。</p>          </div><blockquote><p>也就是说，有可行域 + 可达到最优值 = 有解。</p></blockquote><h2 id="解的存在性">2.3.2、解的存在性</h2><div class="note note-info">            <p><strong>定理 1（Weierstrass 极值定理）</strong>：设 <span class="math inline">\(D \subseteq \mathbb{R}^n\)</span> 是非空凸集，函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 在 <span class="math inline">\(D\)</span> 是<strong>适当的（proper）</strong>、<strong>下半连续的（lower semicontinuous, I.s.c）</strong>凸函数。若 <span class="math inline">\(f\)</span> 的<strong>下水平集非空且有界（lower level-bounded）</strong>，则 <span class="math inline">\(\arg\min_{x \in D} f(x) \neq \emptyset\)</span>。</p>          </div><blockquote><p>1、什么是 <code>proper</code>？</p><p>函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 是适当的（proper）：如果： （1）它在 <span class="math inline">\(D\)</span> 上不恒等于 <span class="math inline">\(+\infty\)</span>：例子：non-proper 函数：<span class="math inline">\(f(x) = +\infty， \forall x \in D\)</span>； （2）对任意 <span class="math inline">\(x \in D\)</span>，有 <span class="math inline">\(f(x) &gt; -\infty\)</span>；例子：non-proper 函数：<span class="math inline">\(f(0) = -\infty\)</span>，$ f(x) &gt; -$, $x  $。</p><p><code>proper</code> ➡️ 函数值不是总是无穷大，且没有点取到负无穷。 <!-- 目标函数是一个有意义的讨论对象，如果硬要定义函数在某些点取到 $-\infty$，那这个优化问题就没有讨论的意义了。 --></p><p>2、什么是 <code>lower semicontinuous</code>？</p><p>函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 是下半连续的（lower semicontinuous, I.s.c）：如果 <span class="math inline">\(\forall x\)</span>，<span class="math inline">\(\liminf_{y \to x} f(y) \ge f(x)\)</span>。</p><p>也可以等价描述为：如果对任意 $ $，集合 <span class="math inline">\(\{x \in D | f(x) \leq \alpha\}\)</span> 是<code>闭集</code>（若任何收敛到 z 的序列<span class="math inline">\(\{z_k\} \subseteq M\)</span> 的极限仍然属于 <span class="math inline">\(M\)</span>，则称 <span class="math inline">\(M\)</span> 是闭集。例如 <span class="math inline">\([0,1]\)</span> 是闭集，因为 <span class="math inline">\(z_k = \frac{1}{k} \in [0,1]\)</span> 且极限 <span class="math inline">\(\lim_{k \in + \infty} z_k = 0 \in [0,1]\)</span>）；<span class="math inline">\((0,1]\)</span> 不是闭集,因为 <span class="math inline">\(\lim_{k \in + \infty} z_k = 0 \notin (0,1]\)</span>。 例如： <span class="math inline">\(f(x) = \begin{cases} 0, x = 0 \\ 1 , x \ne 0 \end{cases}\)</span> 满足 <span class="math inline">\(\liminf_{x \to 0} f = 0 &lt; 1\)</span> (i.s.c)；而 <span class="math inline">\(f(x) = \begin{cases} 1, x = 0 \\ 0 , x \ne 0 \end{cases}\)</span> <span class="math inline">\(\liminf_{x \to 0} f = 1 &gt; 0\)</span> (非 i.s.c)。</p><p><code>lower semicontinuous</code> ➡️ 允许函数值在极限处“跳高”，但不允许“跳低”。</p><p><strong>注意这里有一个坑：连续函数一定是下半连续函数！而下半连续函数不一定是连续函数！这里的下半连续只是一个更弱的条件！（不要被<code>连续</code>二字误导！！！）</strong></p><p>3、什么是 <code>lower level-bounded</code>？</p><p>函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 的下水平集非空且有界（lower level-bounded）：给定 <span class="math inline">\(\alpha \in \mathbb{R}\)</span>，集合 <span class="math inline">\(\{x \in D | f(x) \leq \alpha\}\)</span> 是<code>非空有界集</code>。</p><p>这个条件和 i.s.c 条件结合起来，可以保证给定常数 <span class="math inline">\(\beta \in {\mathbb R}\)</span>，<span class="math inline">\(f(x)\)</span> 的下水平集 <span class="math inline">\(L_a = \{x \in D | f(x) \leq \beta\}\)</span> 是非空有界的闭集，即紧集。紧集里任意序列都有收敛子序列：存在 <span class="math inline">\(\{x_{k_k}\} \to x^\star \in L_a \subset D\)</span>。紧集里的每个点都能取到，从而保证最优解 <span class="math inline">\(x^\star\)</span> 能被取到。</p><p>I.s.c 给出： <span class="math inline">\(f( x^\star ) \le \liminf_{j \to \infty} f(x_{k_j}) = f^\star\)</span>，且 <span class="math inline">\(f^\star \le f(x^\star)\)</span> 总成立，所以 <span class="math inline">\(f(x^\star) = f^\star\)</span>，即 <span class="math inline">\(x^\star\)</span> 是最优解。</p></blockquote><blockquote><p>⚠️⚠️⚠️：这三个条件都是<strong>充分不必要条件</strong>，即：满足这些条件时，凸优化问题一定有解；但凸优化问题有解时，不一定满足这些条件。因此，上述内容其实讨论的是：<strong>有意义的凸优化问题</strong>的解的存在性。（上述内容还有待完善）</p></blockquote><h2 id="解的唯一性">2.3.3、解的唯一性</h2><div class="note note-info">            <p><strong>定理 2</strong>：在定理 1 的基础上，若函数 <span class="math inline">\(f: D \to \mathbb{R}\)</span> 在 <span class="math inline">\(D\)</span> 上严格凸，则存在唯一的 <span class="math inline">\(x^\star \in D\)</span> 使得 <span class="math display">\[\begin{align}f(x^\star) = \min_{x \in D} f(x).\end{align}\]</span></p>          </div><h1 id="凸优化问题的重要性质">2.4、凸优化问题的重要性质</h1><ul><li><strong>性质一</strong>：在一个凸可行域 <span class="math inline">\(D\)</span>上最小化一个凸函数 <span class="math inline">\(f\)</span> 时，<strong>任何局部极小点都是全局极小点</strong>（注意，这里的全局指的是整个凸可行域 <span class="math inline">\(D\)</span>，而不是 <span class="math inline">\(\mathbb{R}^n\)</span>）。对于凸优化问题(5)，该性质可用数学语言描述为：<ul><li><p><strong>如果</strong>存在 <span class="math inline">\(x^\star \in D\)</span> 以及常数 <span class="math inline">\(\rho &gt; 0\)</span> 满足 <span class="math inline">\(\|x^\star - y\|_2 \le \rho\)</span>, <span class="math inline">\(\forall y \in D\)</span>，使得： <span class="math display">\[\begin{align}       f(x^\star) \le f(y), \quad \forall y \in D \text{ 且 } \|x^\star - y\|_2 \le \rho    \end{align}\]</span></p></li><li><p><strong>则</strong> <span class="math inline">\(x^\star\)</span> 也是全局最优解，即：<span class="math inline">\(f(x^\star) \le f(y), \forall y \in D\)</span>。</p></li><li><p>这个性质可以用反证法证明，过程如下：</p><details><p>证明：假设结论不成立，则 <span class="math inline">\(x^\star\)</span> 不是全局最小点。于是存在某个可行点 <span class="math inline">\(\bar y\in D\)</span> 使得 <span class="math display">\[\begin{align}f(\bar y)&lt;f(x^\star).\end{align}\]</span> 由于 <span class="math inline">\(D\)</span> 是凸集，故对任意 <span class="math inline">\(\theta\in[0,1]\)</span>，点 <span class="math display">\[\begin{align}z(\theta) := (1-\theta)x^\star+\theta \bar y\end{align}\]</span> 仍属于 <span class="math inline">\(D\)</span>。</p><p>又由于 <span class="math inline">\(f\)</span> 是凸函数，故对任意 <span class="math inline">\(\theta\in[0,1]\)</span> 有 <span class="math display">\[\begin{align}f\big(z(\theta)\big)\le (1-\theta)f(x^\star)+\theta f(\bar y).\end{align}\]</span> 结合 <span class="math inline">\(f(\bar y)&lt;f(x^\star)\)</span>，可得当任意 <span class="math inline">\(\theta\in(0,1]\)</span> 时 <span class="math display">\[\begin{align}(1-\theta)f(x^\star)+\theta f(\bar y)= f(x^\star)+\theta\big(f(\bar y)-f(x^\star)\big)&lt; f(x^\star),\end{align}\]</span> 从而 <span class="math display">\[\begin{align}f\big(z(\theta)\big)&lt;f(x^\star),\quad \forall\,\theta\in(0,1].\end{align}\]</span> 另一方面，注意到 <span class="math display">\[\begin{align}\|z(\theta)-x^\star\|_2&amp;= \|(1-\theta)x^\star+\theta \bar y-x^\star\|_2= \|\theta(\bar y-x^\star)\|_2= \theta\|\bar y-x^\star\|_2.\end{align}\]</span> 因此只要取 <span class="math display">\[\begin{align}0&lt;\theta\le \min\left\{1,\ \frac{\rho}{\|\bar y-x^\star\|_2}\right\},\end{align}\]</span> 就有 <span class="math inline">\(\|z(\theta)-x^\star\|_2\le \rho\)</span>，且 <span class="math inline">\(z(\theta)\in D\)</span>。 于是由“局部最小”的假设应当满足 <span class="math display">\[\begin{align}f(x^\star)\le f\big(z(\theta)\big).\end{align}\]</span> 但上面已经得到 <span class="math inline">\(f\big(z(\theta)\big)&lt;f(x^\star)\)</span>，矛盾。</p><p>故反设不成立，结论成立，即 <span class="math display">\[\begin{align}f(x^\star)\le f(y),\quad \forall\,y\in D.\end{align}\]</span> 这说明 <span class="math inline">\(x^\star\)</span> 是全局最小点。</p></details></li></ul></li><li><strong>性质二</strong>：如果目标函数是严格凸函数（严格不等号），则全局最优解唯一。对于凸优化问题(5)，该性质可用数学语言描述为：<ul><li><p><strong>如果</strong> 凸优化问题 (5) 存在全局最优解，且目标函数 <span class="math inline">\(f\)</span> 是严格凸函数，</p></li><li><p><strong>则</strong>凸优化问题 (5) 的全局最优解唯一。</p></li><li><p>这个形式也可以用反证法证明，过程如下：</p><details><p>证明：严格凸的定义为：对任意不同的 <span class="math inline">\(x_1,x_2\in D\)</span> 以及任意 <span class="math inline">\(\theta\in(0,1)\)</span>，有 <span class="math display">\[\begin{align}f(\theta x_1+(1-\theta)x_2) &lt; \theta f(x_1)+(1-\theta)f(x_2).\end{align}\]</span> 下面用反证法证明唯一性。假设存在两个不同的全局最优解 <span class="math inline">\(x_1^\star\neq x_2^\star\)</span>，并记最优值为 <span class="math display">\[\begin{align}f^\star := f(x_1^\star)=f(x_2^\star)=\inf_{x\in D} f(x).\end{align}\]</span> 由于 <span class="math inline">\(D\)</span> 是凸集，对任意 <span class="math inline">\(\theta\in(0,1)\)</span>，点 <span class="math display">\[\begin{align}x_\theta := \theta x_1^\star+(1-\theta)x_2^\star\end{align}\]</span> 仍属于 <span class="math inline">\(D\)</span>。由严格凸性得 <span class="math display">\[\begin{align}f(x_\theta)&lt; \theta f(x_1^\star)+(1-\theta)f(x_2^\star)= \theta f^\star+(1-\theta)f^\star= f^\star.\end{align}\]</span> 这意味着存在可行点 <span class="math inline">\(x_\theta\in D\)</span> 使得 <span class="math inline">\(f(x_\theta)&lt;f^\star\)</span>，与 <span class="math inline">\(f^\star\)</span> 为全局最小值矛盾。</p><p>因此不可能存在两个不同的全局最优解，故全局最优解唯一。</p></details></li></ul></li><li><strong>性质三</strong>：凸优化问题的解集为凸集。对于凸优化问题(5)，该性质可用数学语言描述为：<ul><li><p><strong>如果</strong> 凸优化问题 (5) 存在解集 <span class="math inline">\(\mathcal X_{\mathrm{opt}}\)</span>，</p></li><li><p><strong>则</strong> 解集 <span class="math inline">\(\mathcal X_{\mathrm{opt}}\)</span> 是凸集。</p></li><li><p>这个性质可以直接从凸函数和凸集的定义推导出来，证明如下：</p><details><p>证明：任取 <span class="math inline">\(x_1, x_2 \in {\mathcal X}_{\mathrm{opt}}\)</span>，则 <span class="math inline">\(x_1,x_2 \in D\)</span> 且 <span class="math display">\[\begin{align}f(x_1)=f(x_2)=f^\star.\end{align}\]</span> 对任意 <span class="math inline">\(\theta\in[0,1]\)</span>，令 <span class="math display">\[\begin{align}x_\theta:=\theta x_1+(1-\theta)x_2.\end{align}\]</span> 由于 <span class="math inline">\(D\)</span> 是凸集，有 <span class="math inline">\(x_\theta\in D\)</span>。</p><p>又由于 <span class="math inline">\(f\)</span> 是凸函数，得到 <span class="math display">\[\begin{align}f(x_\theta)\le \theta f(x_1)+(1-\theta)f(x_2)= \theta f^\star+(1-\theta)f^\star=f^\star.\end{align}\]</span> 另一方面，由 <span class="math inline">\(f^\star\)</span> 是 <span class="math inline">\(D\)</span> 上的下确界（最优值），对所有 <span class="math inline">\(x\in D\)</span> 均有 <span class="math inline">\(f(x)\ge f^\star\)</span>， 特别地 <span class="math display">\[\begin{align}f(x_\theta)\ge f^\star.\end{align}\]</span> 综合两式可得 <span class="math inline">\(f(x_\theta)=f^\star\)</span>，因此 <span class="math inline">\(x_\theta\in \mathcal X_{\mathrm{opt}}\)</span>。</p><p>故对任意 <span class="math inline">\(x_1,x_2\in\mathcal X_{\mathrm{opt}}\)</span> 及任意 <span class="math inline">\(\theta\in[0,1]\)</span>，均有 <span class="math inline">\(\theta x_1+(1-\theta)x_2\in\mathcal X_{\mathrm{opt}}\)</span>，即 <span class="math inline">\(\mathcal X_{\mathrm{opt}}\)</span> 为凸集。</p></details></li></ul></li></ul><div class="note note-primary">            <p><strong>问题五：性质一有什么作用？如何体现在凸优化问题中？</strong></p><blockquote><p><strong>有待后续讨论</strong></p></blockquote><p><strong>问题六：性质二有什么作用？如何体现在凸优化问题中？</strong></p><blockquote><p><strong>有待后续讨论</strong></p></blockquote><p><strong>问题七：性质三有什么作用？如何体现在凸优化问题中？</strong></p><blockquote><p><strong>有待后续讨论</strong></p></blockquote>          </div>]]></content>
    
    
    <categories>
      
      <category>optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>convex set</tag>
      
      <tag>convex function</tag>
      
      <tag>affine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸优化学习系列 - 2. 凸优化问题分类</title>
    <link href="/2026/01/26/03=Convex_Optimization/CVX-2/"/>
    <url>/2026/01/26/03=Convex_Optimization/CVX-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>这个文档用于梳理几类常见的凸优化问题的标准定义与包含关系。</strong></p></blockquote><h1 id="线性规划linear-program-lp的标准定义">1. 线性规划（Linear Program, LP）的标准定义</h1><div class="note note-info">            <p>线性规划（LP）是指目标函数与约束均为线性（仿射）形式的优化问题。标准形式可写为 <span class="math display">\[\begin{align}\min_{x\in\mathbb{R}^n}\quad &amp; c^\top x\\\text{s.t.}\quad &amp; Dx \le d,\\&amp; Ax = b,\end{align}\]</span> 其中 <span class="math inline">\(c\in\mathbb{R}^n\)</span>，<span class="math inline">\(D\in\mathbb{R}^{p\times n}\)</span>，<span class="math inline">\(d\in\mathbb{R}^p\)</span>，<span class="math inline">\(A\in\mathbb{R}^{m\times n}\)</span>，<span class="math inline">\(b\in\mathbb{R}^m\)</span>，不等式 <span class="math inline">\(Dx\le d\)</span> 按分量理解。</p>          </div><blockquote><p>由于线性函数是凸函数，线性不等式与等式定义的可行域是凸集，因此 LP 始终是凸优化问题。</p></blockquote><hr><h1 id="凸二次规划convex-quadratic-program-qp的标准定义">2. 凸二次规划（Convex Quadratic Program, QP）的标准定义</h1><div class="note note-info">            <p>凸二次规划（QP）是指目标函数为凸二次函数、约束为线性（仿射）形式的问题。标准形式可写为 <span class="math display">\[\begin{align}\min_{x\in\mathbb{R}^n}\quad &amp; c^\top x + \frac{1}{2}x^\top Qx\\\text{s.t.}\quad &amp; Dx \le d,\\&amp; Ax = b,\end{align}\]</span> 其中 <span class="math inline">\(Q\in\mathbb{S}^n\)</span>（对称矩阵）。当且仅当<span class="math inline">\(Q\succeq 0\)</span>（半正定）时，上述 QP 为<strong>凸二次规划</strong>；若 <span class="math inline">\(Q\)</span> 非半正定，则问题一般<strong>非凸</strong>。</p>          </div><hr><h1 id="二阶锥规划second-order-cone-program-socp的标准定义">3. 二阶锥规划（Second-Order Cone Program, SOCP）的标准定义</h1><div class="note note-info">            <p>二阶锥规划（SOCP）是指线性目标 + 线性等式约束 + 若干个二阶锥（SOC）约束的问题。常见标准形式为 <span class="math display">\[\begin{align}\min_{x\in\mathbb{R}^n}\quad &amp; c^\top x\\\text{s.t.}\quad &amp; \|D_i x + d_i\|_2 \le e_i^\top x + f_i,\quad i=1,\dots,p,\\&amp; Ax = b,\end{align}\]</span> 其中 <span class="math inline">\(D_i\in\mathbb{R}^{k_i\times n}\)</span>，<span class="math inline">\(d_i\in\mathbb{R}^{k_i}\)</span>，<span class="math inline">\(e_i\in\mathbb{R}^{n}\)</span>，<span class="math inline">\(f_i\in\mathbb{R}\)</span>。</p>          </div><p>二阶锥（Lorentz cone）的定义为 <span class="math display">\[\begin{align}\mathcal{Q}_{k+1} \;=\; \{(u,t)\in\mathbb{R}^k\times\mathbb{R}\;:\;\|u\|_2\le t\}.\end{align}\]</span> 因此 SOCP 约束 <span class="math inline">\(\|D_i x + d_i\|_2 \le e_i^\top x + f_i\)</span> 等价于 <span class="math display">\[\begin{align}(D_i x + d_i,\; e_i^\top x + f_i)\in \mathcal{Q}_{k_i+1}.\end{align}\]</span></p><hr><h1 id="半正定规划semidefinite-program-sdp的标准定义">4. 半正定规划（Semidefinite Program, SDP）的标准定义</h1><div class="note note-info">            <p>半正定规划（SDP）是指线性目标 + 线性等式约束 + 线性矩阵不等式（LMI）约束的问题。常用标准形式为 <span class="math display">\[\begin{align}\min_{x\in\mathbb{R}^n}\quad &amp; c^\top x\\\text{s.t.}\quad &amp; x_1F_1 + \cdots + x_nF_n \preceq F_0,\\&amp; Ax = b,\end{align}\]</span> 其中 <span class="math inline">\(F_i\in\mathbb{S}^d\)</span>（<span class="math inline">\(d\times d\)</span> 对称矩阵），<span class="math inline">\(\preceq\)</span> 表示半正定序（<span class="math inline">\(M\preceq N \Leftrightarrow N-M\succeq 0\)</span>）。</p>          </div><p>将矩阵不等式改写为“落在半正定锥中”的形式更直接： <span class="math display">\[\begin{align}F_0 - \sum_{i=1}^n x_iF_i \in \mathbb{S}^d_+,\end{align}\]</span> 其中 <span class="math inline">\(\mathbb{S}^d_+\)</span> 为半正定锥（闭凸锥）。</p><hr><h1 id="锥规划conic-program的标准定义">5. 锥规划（Conic Program）的标准定义</h1><h2 id="锥规划的标准定义">5.1 锥规划的标准定义</h2><div class="note note-info">            <p>锥规划（Conic Program）以“某个线性映射的像落在闭凸锥 <span class="math inline">\(K\)</span> 中”为核心约束。标准形式可写为 <span class="math display">\[\begin{align}\min_{x\in\mathbb{R}^n}\quad &amp; c^\top x\\\text{s.t.}\quad &amp; Ax=b,\\&amp; D(x)+d \in K,\end{align}\]</span> 其中 - <span class="math inline">\(c\in\mathbb{R}^n\)</span>，<span class="math inline">\(A\in\mathbb{R}^{m\times n}\)</span>，<span class="math inline">\(b\in\mathbb{R}^m\)</span>； - <span class="math inline">\(D:\mathbb{R}^n\to Y\)</span> 是线性映射，<span class="math inline">\(d\in Y\)</span>； - <span class="math inline">\(Y\)</span> 是欧氏空间（可看作带内积的有限维向量空间）； - <span class="math inline">\(K\subseteq Y\)</span> 是<strong>闭凸锥</strong>（closed convex cone）。</p>          </div><hr><h1 id="五类凸优化问题的包含关系">6. 五类凸优化问题的包含关系</h1><p>我们要说明如下包含链： <span class="math display">\[\begin{align}\mathrm{LPs}\subseteq \mathrm{QPs}\subseteq \mathrm{SOCPs}\subseteq \mathrm{SDPs}\subseteq \mathrm{Conic\ Programs}.\end{align}\]</span> 下面逐个证明“前者是后者的特例/可等价表示”。</p><hr><h2 id="证明mathrmlpssubseteq-mathrmqps">6.1 证明：<span class="math inline">\(\mathrm{LPs}\subseteq \mathrm{QPs}\)</span></h2><p>给定任意 LP： <span class="math display">\[\begin{align}\min_x\; c^\top x\quad \text{s.t.}\; Dx\le d,\;Ax=b,\end{align}\]</span> 取 QP 中 <span class="math inline">\(Q=0\)</span>（零矩阵），则 <span class="math display">\[\begin{align}c^\top x + \frac12 x^\top Qx = c^\top x,\end{align}\]</span> 并且约束不变，因此每个 LP 都是一个（凸）QP 的特例，从而 <span class="math inline">\(\mathrm{LPs}\subseteq \mathrm{QPs}\)</span>。</p><hr><h2 id="证明mathrmqpssubseteq-mathrmsocps凸-qp-的-socp-表示">6.2 证明：<span class="math inline">\(\mathrm{QPs}\subseteq \mathrm{SOCPs}\)</span>（凸 QP 的 SOCP 表示）</h2><p>考虑凸 QP： <span class="math display">\[\begin{align}\min_x\quad &amp; c^\top x + \frac12 x^\top Qx\\\text{s.t.}\quad &amp; Dx\le d,\;Ax=b,\;\;Q\succeq 0.\end{align}\]</span> 用上图形式的 SOCP（线性目标）通常通过<strong>引入上图（epigraph）变量</strong>实现。令 <span class="math inline">\(t\in\mathbb{R}\)</span>，等价改写为 <span class="math display">\[\begin{align}\min_{x,t}\quad &amp; c^\top x + t\\\text{s.t.}\quad &amp; Dx\le d,\;Ax=b,\\&amp; t \ge \frac12 x^\top Qx.\end{align}\]</span> 由于 <span class="math inline">\(Q\succeq 0\)</span>，存在矩阵 <span class="math inline">\(R\)</span> 使得 <span class="math inline">\(Q=R^\top R\)</span>（如 Cholesky 或谱分解后取平方根），则 <span class="math display">\[\begin{align}x^\top Qx = x^\top R^\top R x = \|Rx\|_2^2.\end{align}\]</span> 因此约束变为 <span class="math display">\[\begin{align}t \ge \frac12 \|Rx\|_2^2.\end{align}\]</span> 该二次上界可用<strong>旋转二阶锥</strong>（rotated SOC）表示：旋转二阶锥定义为 <span class="math display">\[\begin{align}\mathcal{Q}_r^{k+2}=\{(u,v,w)\in\mathbb{R}\times\mathbb{R}\times\mathbb{R}^k:\; u\ge 0,\; v\ge 0,\; 2uv\ge \|w\|_2^2\}.\end{align}\]</span> 令 <span class="math inline">\(u=t,\;v=1,\;w=Rx\)</span>，则 <span class="math display">\[\begin{align}(t,1,Rx)\in \mathcal{Q}_r^{k+2}\;\Longleftrightarrow\;t\ge \frac12\|Rx\|_2^2.\end{align}\]</span> 于是凸 QP 可改写为带（旋转）SOC 约束的 SOCP，因此 <span class="math inline">\(\mathrm{QPs}\subseteq \mathrm{SOCPs}\)</span>（在允许旋转 SOC 的标准 SOCP 框架下成立；工程与优化文献中通常默认 SOCP 允许该等价变换）。</p><hr><h2 id="证明mathrmsocpssubseteq-mathrmsdpssoc-约束等价为-lmi">6.3 证明：<span class="math inline">\(\mathrm{SOCPs}\subseteq \mathrm{SDPs}\)</span>（SOC 约束等价为 LMI）</h2><p>SOCP 的核心约束为 <span class="math display">\[\begin{align}\|u\|_2 \le t,\end{align}\]</span> 其中 <span class="math inline">\(u\in\mathbb{R}^k\)</span>，<span class="math inline">\(t\in\mathbb{R}\)</span>。证明其可写为半正定约束（LMI）。</p><p>考虑块对称矩阵 <span class="math display">\[\begin{align}M=\begin{bmatrix}tI_k &amp; u\\u^\top &amp; t\end{bmatrix}.\end{align}\]</span> 若 <span class="math inline">\(M\succeq 0\)</span>，则必有 <span class="math inline">\(t\ge 0\)</span>，并由 Schur 补（对 <span class="math inline">\(tI_k\)</span>）可得 <span class="math display">\[\begin{align}M\succeq 0\;\Longleftrightarrow\;tI_k\succeq 0\ \text{且}\ t - u^\top (tI_k)^{-1}u \ge 0\;\Longleftrightarrow\;t\ge 0,\ \ t - \frac{1}{t}\|u\|_2^2 \ge 0.\end{align}\]</span> 当 <span class="math inline">\(t&gt;0\)</span> 时，上式等价于 <span class="math display">\[\begin{align}t^2 \ge \|u\|_2^2 \;\Longleftrightarrow\; \|u\|_2 \le t.\end{align}\]</span> 当 <span class="math inline">\(t=0\)</span> 时，<span class="math inline">\(M\succeq 0\)</span> 强制 <span class="math inline">\(u=0\)</span>，也满足 <span class="math inline">\(\|u\|_2\le t\)</span>。因此 <span class="math display">\[\begin{align}\|u\|_2 \le t\;\Longleftrightarrow\;\begin{bmatrix}tI_k &amp; u\\u^\top &amp; t\end{bmatrix}\succeq 0.\end{align}\]</span> SOCP 中每个 SOC 约束都可用一个 LMI 表示，线性目标与仿射约束保持不变，因此 SOCP 是 SDP 的特例：<span class="math inline">\(\mathrm{SOCPs}\subseteq \mathrm{SDPs}\)</span>。</p><hr><h2 id="证明mathrmsdpssubseteq-mathrmconic-programs">6.4 证明：<span class="math inline">\(\mathrm{SDPs}\subseteq \mathrm{Conic\ Programs}\)</span></h2><p>SDP 的矩阵不等式 <span class="math display">\[\begin{align}\sum_{i=1}^n x_iF_i \preceq F_0\end{align}\]</span> 等价于 <span class="math display">\[\begin{align}F_0-\sum_{i=1}^n x_iF_i \in \mathbb{S}_+^d.\end{align}\]</span> 令欧氏空间 <span class="math inline">\(Y=\mathbb{S}^d\)</span>，闭凸锥 <span class="math inline">\(K=\mathbb{S}_+^d\)</span>，并定义线性映射 <span class="math display">\[\begin{align}D(x)= -\sum_{i=1}^n x_iF_i,\qquad d=F_0,\end{align}\]</span> 则约束恰为 <span class="math inline">\(D(x)+d\in K\)</span>。同时保留线性等式约束 <span class="math inline">\(Ax=b\)</span> 与线性目标 <span class="math inline">\(c^\top x\)</span>，因此每个 SDP 都是锥规划的特例，从而 <span class="math display">\[\begin{align}\mathrm{SDPs}\subseteq \mathrm{Conic\ Programs}.\end{align}\]</span></p><hr><h2 id="小结">6.5 小结</h2><p>由 6.1–6.4 的逐步构造与等价变换，得到 <span class="math display">\[\begin{align}\mathrm{LPs}\subseteq \mathrm{QPs}\subseteq \mathrm{SOCPs}\subseteq \mathrm{SDPs}\subseteq \mathrm{Conic\ Programs}.\end{align}\]</span> 该关系可通过下图直观表达。</p><figure><img src="/img/cvx-problem-relation.png" alt="CVX问题包含关系"><figcaption aria-hidden="true">CVX问题包含关系</figcaption></figure><blockquote><p><strong>这条链表达的是：越往右，允许的锥/矩阵锥结构越一般，建模能力越强，但求解器实现与计算代价通常也越高。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>convex set</tag>
      
      <tag>convex function</tag>
      
      <tag>affine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸优化学习系列 - 3. 一阶方法</title>
    <link href="/2026/01/26/03=Convex_Optimization/CVX-3/"/>
    <url>/2026/01/26/03=Convex_Optimization/CVX-3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.stat.cmu.edu/~ryantibs/convexopt/">CMU 课程10-725-2019</a>的 <a href="https://www.stat.cmu.edu/~ryantibs/convexopt/scribes/convex-opt-scribed.pdf">Lecture 3</a> 和 <a href="https://www.stat.cmu.edu/~ryantibs/convexopt/scribes/canonical-probs-scribed.pdf">Lecture 4</a> 分别介绍了 <code>问题怎么写才是凸的（如何构造凸问题）</code> 以及 <code>某些变换后的问题为什么还是凸的（凸性保持）</code>，作为<strong>背景/预备知识</strong>，暂时不作深入讨论，遇到时再补充。 这个文档基于 <a href="https://www.stat.cmu.edu/~ryantibs/convexopt/">CMU 课程10-725-2019</a> 的 Lecture 5-9，整理和总结凸优化问题的一阶求解方法，求解原理、收敛性与复杂度，并给出对比分析。</p><h1 id="一阶方法总结">一阶方法总结</h1><blockquote><p><strong><code>一阶</code>是指求解过程中只用到目标函数的一阶信息，即 <span class="math inline">\(\nabla f\)</span>，而不适用二阶信息（如 Hessian 矩阵 <span class="math inline">\(\nabla^2 f\)</span>）。一阶方法通常每步计算开销较低，适合大规模问题，但收敛速度相对较慢。</strong></p></blockquote><h2 id="梯度下降gradient-descent-gd">1. 梯度下降（Gradient Descent, GD）</h2><p><strong>问题设定</strong>： 最小化光滑凸函数 <span class="math inline">\(f(x)\)</span>，假设 <span class="math inline">\(\nabla f\)</span> 为 <span class="math inline">\(L\)</span>-Lipschitz。</p><p><strong>迭代格式</strong>： <span class="math display">\[\begin{align} x^{(k)} = x^{(k-1)} - t_k \nabla f(x^{(k-1)}), \quad k=1,2,\dots\end{align}\]</span></p><p><strong>收敛性与速度</strong>：</p><ul><li>若 <span class="math inline">\(\nabla f\)</span> 为 <span class="math inline">\(L\)</span>-Lipschitz，则函数值收敛率为 <span class="math inline">\(O(1/k)\)</span>，达到 <span class="math inline">\(\varepsilon\)</span> 精度需 <span class="math inline">\(O(1/\varepsilon)\)</span> 次迭代。</li><li>若 <span class="math inline">\(f\)</span> 进一步 <span class="math inline">\(m\)</span>-强凸，则线性收敛： <span class="math display">\[\begin{align}f(x^{(k)}) - f^* = O(\gamma^k), \quad 0&lt;\gamma&lt;1\end{align}\]</span> 因而迭代复杂度为 <span class="math inline">\(O(\log(1/\varepsilon))\)</span>。</li><li>条件数 <span class="math inline">\(L/m\)</span> 越大，收敛越慢。</li></ul><p><strong>复杂度</strong>：每步一次梯度计算（成本依赖问题规模）。</p><p><strong>优缺点</strong>：</p><ul><li>优：简单、每步便宜；对良好条件数的强凸问题很快。</li><li>缺：要求可微；对病态问题慢。</li></ul><hr><h2 id="次梯度法subgradient-method">2. 次梯度法（Subgradient Method）</h2><p><strong>次梯度定义</strong>（用于非光滑凸函数）： <span class="math display">\[\begin{align} f(y) \ge f(x) + g^T (y-x), \quad g \in \partial f(x)\end{align}\]</span></p><p><strong>迭代格式</strong>： <span class="math display">\[\begin{align} x^{(k)} = x^{(k-1)} - t_k g^{(k-1)}, \quad g^{(k-1)} \in \partial f(x^{(k-1)})\end{align}\]</span> 并用当前最优函数值的迭代点 <span class="math inline">\(x_{\text{best}}^{(k)}\)</span> 作为输出。</p><p><strong>收敛性与速度</strong>（<span class="math inline">\(f\)</span> 为 <span class="math inline">\(G\)</span>-Lipschitz）： - 固定步长 <span class="math inline">\(t\)</span>： <span class="math display">\[\begin{align}  \lim_{k\to\infty} f(x_{\text{best}}^{(k)}) \le f^* + \frac{G^2 t}{2}  \end{align}\]</span> - 递减步长（平方可和但不可和）：<span class="math inline">\(f(x_{\text{best}}^{(k)}) \to f^*\)</span>。 - 收敛率：<span class="math inline">\(O(1/\varepsilon^2)\)</span>（明显慢于 GD 的 <span class="math inline">\(O(1/\varepsilon)\)</span>）。</p><p><strong>复杂度</strong>：每步一次次梯度计算；不保证单调下降。</p><p><strong>优缺点</strong>：</p><ul><li>优：可处理不可微凸问题，适用面广。</li><li>缺：收敛慢；对步长较敏感。</li></ul><hr><h2 id="近端梯度下降proximal-gradient-descent-pgd">3. 近端梯度下降（Proximal Gradient Descent, PGD）</h2><p><strong>问题设定</strong>：复合目标 <span class="math inline">\(f(x)=g(x)+h(x)\)</span>，其中 <span class="math inline">\(g\)</span> 光滑凸、<span class="math inline">\(h\)</span> 凸且可计算近端算子。</p><p><strong>近端映射</strong>： <span class="math display">\[\begin{align} \mathrm{prox}_{h,t}(x)=\arg\min_z \; \frac{1}{2t}\|x-z\|_2^2 + h(z)\end{align}\]</span></p><p><strong>迭代格式</strong>： <span class="math display">\[\begin{align} x^{(k)} = \mathrm{prox}_{h,t_k}\big(x^{(k-1)}-t_k \nabla g(x^{(k-1)})\big)\end{align}\]</span></p><p><strong>收敛性与速度</strong>： - 若 <span class="math inline">\(\nabla g\)</span> 为 <span class="math inline">\(L\)</span>-Lipschitz，则 <span class="math display">\[\begin{align}  f(x^{(k)})-f^* = O(1/k)  \end{align}\]</span> 迭代复杂度 <span class="math inline">\(O(1/\varepsilon)\)</span>。</p><p><strong>复杂度</strong>：每步一次梯度 + 一次 prox 计算（若 prox 便宜则总体高效）。</p><p><strong>优缺点</strong>：</p><ul><li>优：可处理常见非光滑正则（如 <span class="math inline">\(\ell_1\)</span>、核范数），保留 GD 的速率。</li><li>缺：prox 若代价高会成为瓶颈；误差近端会影响速率。</li></ul><hr><h2 id="加速近端梯度accelerated-pgd-nesterov-加速">4. 加速近端梯度（Accelerated PGD / Nesterov 加速）</h2><p><strong>核心思想</strong>：在 PGD 上加入动量外推；当 <span class="math inline">\(h=0\)</span> 时退化为加速梯度法。</p><p><strong>典型迭代</strong>（讲义中的形式）： <span class="math display">\[\begin{align} v^{(k)} &amp;= x^{(k-1)} + \frac{k-2}{k+1}\big(x^{(k-1)}-x^{(k-2)}\big) \\ x^{(k)} &amp;= \mathrm{prox}_{h,t_k}\big(v^{(k)}-t_k \nabla g(v^{(k)})\big)\end{align}\]</span></p><p><strong>收敛性与速度</strong>： - 函数值收敛率达到 <span class="math inline">\(O(1/k^2)\)</span>（一阶方法最优）。 - 相应的精度复杂度为 <span class="math inline">\(O(1/\sqrt{\varepsilon})\)</span>。</p><p><strong>复杂度</strong>：每步一次梯度 + 一次 prox；但并非单调下降。</p><p><strong>优缺点</strong>：</p><ul><li>优：显著加速，理论最优速率。</li><li>缺：对步长/动量更敏感；不一定单调下降。</li></ul><hr><h2 id="随机梯度下降stochastic-gradient-descent-sgd">5. 随机梯度下降（Stochastic Gradient Descent, SGD）</h2><p><strong>问题设定</strong>：最小化均值型目标 <span class="math inline">\(f(x)=\frac{1}{m}\sum_{i=1}^m f_i(x)\)</span>。</p><p><strong>迭代格式</strong>： <span class="math display">\[\begin{align} x^{(k)} = x^{(k-1)} - t_k \nabla f_{i_k}(x^{(k-1)})\end{align}\]</span> 其中 <span class="math inline">\(i_k\)</span> 为随机抽样索引，<span class="math inline">\(\mathbb{E}[\nabla f_{i_k}(x)] = \nabla f(x)\)</span>。</p><p><strong>收敛性与速度</strong>：</p><ul><li>对凸函数、递减步长： <span class="math display">\[\begin{align}\mathbb{E}[f(x^{(k)})]-f^* = O(1/k)\end{align}\]</span></li><li>即使强凸+Lipschitz 梯度，SGD 仍只有 <span class="math inline">\(O(1/k)\)</span> 的期望收敛，不具备 GD 的线性收敛。</li></ul><p><strong>复杂度</strong>：</p><ul><li>一次 batch 梯度：<span class="math inline">\(O(np)\)</span>；</li><li>一次随机梯度：<span class="math inline">\(O(p)\)</span>；</li><li>mini-batch 大小 <span class="math inline">\(b\)</span>：<span class="math inline">\(O(bp)\)</span>。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优：单步开销小，适合大规模数据。</li><li>缺：噪声导致收敛慢；需谨慎设置步长/停止策略。</li></ul><hr><h2 id="方法性质对比">6. 方法性质对比</h2><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">目标函数<span class="math inline">\(f\)</span></th><th style="text-align: center;">每步计算</th><th style="text-align: center;">典型收敛率（<span class="math inline">\(f\)</span>一般凸）</th><th style="text-align: center;">主要优点</th><th style="text-align: center;">主要缺点</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">GD</td><td style="text-align: center;">光滑凸</td><td style="text-align: center;">1 次全梯度</td><td style="text-align: center;"><span class="math inline">\(O(1/k)\)</span></td><td style="text-align: center;">简单、稳定</td><td style="text-align: center;">需可微</td></tr><tr class="even"><td style="text-align: center;">Subgradient</td><td style="text-align: center;">非光滑凸</td><td style="text-align: center;">1 次次梯度</td><td style="text-align: center;"><span class="math inline">\(O(1/\sqrt{k})\)</span></td><td style="text-align: center;">目标函数无需可微</td><td style="text-align: center;">收敛慢</td></tr><tr class="odd"><td style="text-align: center;">PGD</td><td style="text-align: center;">复合凸</td><td style="text-align: center;">1 梯度 + 1 prox</td><td style="text-align: center;"><span class="math inline">\(O(1/k)\)</span></td><td style="text-align: center;">目标函数无需可微</td><td style="text-align: center;">prox 可能昂贵</td></tr><tr class="even"><td style="text-align: center;">Acc-PGD</td><td style="text-align: center;">复合凸</td><td style="text-align: center;">1 梯度 + 1 prox</td><td style="text-align: center;"><span class="math inline">\(O(1/k^2)\)</span></td><td style="text-align: center;">理论最优速率</td><td style="text-align: center;">参数敏感、非单调</td></tr><tr class="odd"><td style="text-align: center;">SGD</td><td style="text-align: center;">均值目标</td><td style="text-align: center;">1 次随机梯度</td><td style="text-align: center;"><span class="math inline">\(O(1/\sqrt{k})\)</span></td><td style="text-align: center;">适合大数据</td><td style="text-align: center;">噪声、收敛慢</td></tr></tbody></table><hr><h2 id="总结">7. 总结</h2><ul><li>小中规模、光滑凸：优先 GD；若强凸且条件数好，GD 收敛很快。</li><li>非光滑凸：若有可计算的 prox，优先 PGD/Acc-PGD；否则用次梯度法。</li><li>大规模数据：SGD 是首选，尤其当全梯度代价高时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>convex set</tag>
      
      <tag>convex function</tag>
      
      <tag>affine</tag>
      
      <tag>gradient descent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/01/23/03=Convex_Optimization/CVX_list/"/>
    <url>/2026/01/23/03=Convex_Optimization/CVX_list/</url>
    
    <content type="html"><![CDATA[<p>Convex Optimization</p><h1 id="mit">MIT</h1><ul><li><a href="https://www.mit.edu/~gfarina/67220/">Gabriele Farina, MIT-6.7220, Nonlinear Optimization, Spring 2025</a></li></ul><h1 id="princeton">Princeton</h1><ul><li><a href="https://aaa.princeton.edu/orf523">Amir Ali Ahmadi, Princeton, ORF523, Convex and Conic Optimization, Spring 2025</a></li><li><a href="https://aaa.princeton.edu/orf363">Amir Ali Ahmadi, Princeton, ORF363, Computing and Optimization, Fall 2025</a></li></ul><h1 id="cmu">CMU</h1><ul><li><a href="https://www.stat.cmu.edu/~siva/teaching/725/">Sivaraman Balakrishnan, CMU, 10-725, Convex Optimization, Spring 2023</a></li><li><a href="https://www.stat.cmu.edu/~ryantibs/convexopt/">Ryan Tibshirani, CMU, 10-725, Convex Optimization, Fall 2019</a></li><li><a href="https://www.cs.cmu.edu/~ggordon/10725-F12/schedule.html">Geoff Gordon, CMU, 10-725, Convex Optimization, Fall 2012</a></li></ul><h1 id="cornell">Cornell</h1><ul><li><a href="https://www.cs.cornell.edu/courses/cs6787/2024sp/">Christopher De Sa, Cornell, CS6787 Advanced Machine Learning Systems Spring 2024</a></li></ul><h1 id="paris">Paris</h1><ul><li><a href="https://www.di.ens.fr/~aspremon/OptConvexeM2.html">Alexandre d’Aspremont, ENS, Convex Optimization, Algorithms and Applications, Fall 2025</a></li></ul><h1 id="upenn">UPenn</h1><ul><li><a href="https://nikolaimatni.github.io/courses/ese605-spring2023/index.html">Nikolai Matni, UPenn, ESE 6050, Modern Convex Optimization, Spring 2023</a></li></ul><h1 id="uw-madison">UW-Madison</h1><ul><li><a href="https://pages.cs.wisc.edu/~yudongchen/cs726_sp25/">Yudong Chen, UW-Madison, Stat 726, Nonlinear Optimization I, Spring 2025</a></li></ul><h1 id="dtu">DTU</h1><ul><li><a href="https://people.compute.dtu.dk/mskan/convexopt.html">Martin S. Andersen, DTU, Convex Optimization, 2023</a></li></ul><h1 id="johns-hopkins">Johns Hopkins</h1><ul><li><a href="https://mateodd25.github.io/nonlinear/">Mateo Díaz, Johns Hopkins, 553.761, Nonlinear Optimization I, Fall 2024</a></li><li><a href="https://mateodd25.github.io/nonlinear2/">Mateo Díaz, Johns Hopkins, 553.763, Nonlinear Optimization II, Spring 2025</a></li></ul><h1 id="epfl">EPFL</h1><ul><li><a href="https://github.com/epfml/OptML_course">Bernd Gärtner &amp; Martin Jaggi, EPFL,Lecture notes</a></li></ul><h1 id="eth">ETH</h1><ul><li><a href="https://ti.inf.ethz.ch/ew/courses/CG13/index.html">Computational Geometry, ETH, 2013</a></li></ul><h1 id="harvard">Harvard</h1><ul><li><a href="https://hankyang.seas.harvard.edu/Semidefinite/">Heng Yang, Havard, Semidefinite Optimization and Relaxation</a></li></ul><h1 id="univ-of-graz">Univ of Graz</h1><ul><li><a href="https://imsc.uni-graz.at/clason/skripte/OptimDataScience25.pdf">Christian Clason, Univ of Graz, Optimization for Data Science, SS 2025</a></li></ul><h1 id="rochester">Rochester</h1><ul><li><a href="https://jiaming-liang.github.io/OPTML.html">Jiaming Liang, Rochester, Optimization for Machine Learning, Fall 2025</a></li><li><a href="https://jiaming-liang.github.io/CONTALG.html">Jiaming Liang, Rochester, CSC574/DSCC574-1 Continuous Algorithms for Optimization and Sampling, Spring 2024</a></li><li><a href="https://jiaming-liang.github.io/NLOPT.html">Jiaming Liang, Rochester, MATH294 Nonlinear Optimization, Spring 2025</a></li></ul><h1 id="pku">PKU</h1><ul><li><a href="https://kunyuan827.github.io/llmopt2026/">Kun Yuan, PKU, Optimization for Large Language Models, 2026</a></li><li><a href="https://kunyuan827.github.io/dlopt2025/">Kun Yuan, PKU, Optimization for Deep Learning, 2025 Fall</a></li><li><a href="https://kunyuan827.github.io/dlopt2025/">Kun Yuan, PKU, Introduction to Foundation Models, 2025 Spring</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/01/23/SDP_list/"/>
    <url>/2026/01/23/SDP_list/</url>
    
    <content type="html"><![CDATA[<p>Semi-definite Programming</p><h1 id="mit">MIT</h1><h2 id="robert-freund">Robert Freund</h2><ul><li><a href="https://ocw.mit.edu/courses/15-084j-nonlinear-programming-spring-2004/">Robert Freund, MIT, 15.084J, Nonlinear Programming, Spring 2004</a>, <a href="https://ocw.mit.edu/courses/15-084j-nonlinear-programming-spring-2004/a632b565602fd2eb3be574c537eea095_lec23_semidef_opt.pdf">Brief Notes</a></li></ul><h2 id="dimitri-bertsekas">Dimitri Bertsekas</h2><ul><li><a href="https://ocw.mit.edu/courses/6-252j-nonlinear-programming-spring-2003/">Dimitri Bertsekas, MIT, 6.252J, Nonlinear Programming, Spring 2003</a></li><li><a href="https://ocw.mit.edu/courses/6-253-convex-analysis-and-optimization-spring-2012/">Dimitri Bertsekas, MIT, 6.253, Convex Analysis and Optimization, Spring 2012</a>, <a href="https://web.mit.edu/6.253/www/">Additional Link</a></li></ul><h2 id="dimitris-bertsimas">Dimitris Bertsimas</h2><ul><li><a href="https://ocw.mit.edu/courses/6-251j-introduction-to-mathematical-programming-fall-2009/">Dimitris Bertsimas, MIT, 6.251J, Introduction to Mathematical Programming, Fall 2009</a></li><li><a href="https://ocw.mit.edu/courses/15-093j-optimization-methods-fall-2009/">Dimitris Bertsimas, MIT, 15.093J, Optimization Methods, Fall 2009</a></li><li><a href="https://ocw.mit.edu/courses/15-083j-integer-programming-and-combinatorial-optimization-fall-2009/">Dimitris Bertsimas, MIT, 15.083J, Integer Programming and Combinatorial Optimization, Fall 2009</a></li></ul><h2 id="pablo-parrilo">Pablo Parrilo</h2><ul><li><a href="https://ocw.mit.edu/courses/6-079-introduction-to-convex-optimization-fall-2009/">Pablo Parrilo, MIT, 6.079, Introduction to Convex Optimization, Fall 2009</a></li><li><a href="https://ocw.mit.edu/courses/6-972-algebraic-techniques-and-semidefinite-optimization-spring-2006/">Pablo Parrilo, MIT, 6.972, Algebraic Techniques and Semidefinite Optimization, Spring 2006</a></li><li><a href="https://canvas.mit.edu/courses/26283">Pablo Parrilo, MIT, 6.7230, Algebraic techniques and semidefinite programming, Spring 2024</a></li><li><a href="https://canvas.mit.edu/courses/16629">Pablo Parrilo, MIT, 6.S084, Linear Algebra and Optimization, Fall 2022</a></li></ul><h2 id="theo-diamandis">Theo Diamandis</h2><ul><li><a href="https://tjdiamandis.github.io/convex-short-course/">Theo Diamandis, MIT, 6.S098, Intro to Applied Convex Optimization</a></li></ul><h1 id="stanford">Stanford</h1><ul><li><a href="https://web.stanford.edu/class/ee364a/lectures.html">Stephen Boyd, Stanford, EE364a, Convex Optimization I</a></li><li><a href="https://web.stanford.edu/class/ee364b/lectures.html">Stephen Boyd, Stanford, EEE364b, Convex Optimization II</a></li><li><a href="https://web.stanford.edu/~boyd/papers/cvx_short_course.html">Stephen Boyd, Stanford, Convex Optimization Short Course, 2015</a></li></ul><h1 id="ucla">UCLA</h1><ul><li><a href="https://www.seas.ucla.edu/~vandenbe/ee236a/ee236a.html">Lieven Vandenberghe, EE236A, Linear Programming, Fall 2013-14</a></li><li><a href="https://www.seas.ucla.edu/~vandenbe/ee236b/ee236b.html">Lieven Vandenberghe, EE236B, Convex Optimization, Winter 2025</a></li><li><a href="https://www.seas.ucla.edu/~vandenbe/ee236c.html">Lieven Vandenberghe, EE236C, Optimization Methods for Large-Scale Systems, Spring 2022</a></li></ul><h1 id="cambridge">Cambridge</h1><ul><li><a href="https://www.damtp.cam.ac.uk/user/hf323/M19-OPT/index.html">Hamza Fawzi, Cambridge, Michaelmas 2019, Topics in Convex Optimisation (optimization algorithms)</a></li></ul><h1 id="uc-berkeley">UC Berkeley</h1><h2 id="ee227at">EE227AT</h2><ul><li><a href="https://people.eecs.berkeley.edu/~elghaoui/Teaching/EECS127/">Laurent El Ghaoui, UC Berkeley, EE227AT, Optimization Models, Fall 2018</a>, <a href="https://sites.google.com/view/eecs-127227at/material">Google</a>, <a href="https://github.com/vighneshiyer/ee227a">Github</a></li></ul><h2 id="ee227bt">EE227BT</h2><ul><li><a href="https://people.eecs.berkeley.edu/~elghaoui/Teaching/EE227BT/">Laurent El Ghaoui, UC Berkeley, EE227BT, Convex Optimization, Fall 2019</a></li><li><a href="https://www.argmin.net/p/convex-optimization-live-blog">Ben Recht, UC Berkeley, EECS227BT, Convex Optimization, Fall 2024.</a> ## EE 227C</li><li><a href="https://ee227c.github.io/">Moritz Hardt, UC Berkeley, EE227C, Convex Optimization and Approximation, Spring 2018</a></li><li><a href="https://people.eecs.berkeley.edu/~brecht/eecs227c.html">Ben Recht, UC Berkeley, EECS227C, Convex Optimization and Approximation, Spring 2016</a> ##</li><li><a href="https://people.eecs.berkeley.edu/~prasad/spring2026.html">Prasad Raghavendra, UC Berkeley, CS 294, Semidefinite Programming and Sum-of-Squares Proofs, Spring 2026</a>, <a href="https://www.youtube.com/watch?v=tMWZw9f3J48&amp;list=PL3NB_Sd9CrX-6CeApf12demgpe2PO4k8c">Video</a>, <a href="https://www.sumofsquares.org/public/index.html">Lecture Notes</a></li></ul><h1 id="cmu">CMU</h1><ul><li><a href="https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15859-f11/www/">Anupam Gupta, 15-859(E), Linear and Semidefinite Programming, Fall 2011</a>, <a href="https://lpsdp.wordpress.com/">Course Blog</a></li></ul><h1 id="cornell">Cornell</h1><ul><li><a href="https://people.orie.cornell.edu/miketodd/orie6327/orie6327.html">Chaoxu Tong, Cornell, ORIE 6327, Semidefinite Programming, Spring 2012</a></li></ul><h1 id="univ-of-toronto">Univ of Toronto</h1><ul><li><a href="https://www.cs.toronto.edu/~avner/teaching/2411/">Avner Magen, UT, CSC 2411H, Linear and Semidefinite Programming and Combinatorial Optimization, Spring 2009</a></li></ul><h1 id="univ-of-waterloo">Univ of Waterloo</h1><ul><li><a href="https://cs.uwaterloo.ca/~r5olivei/courses/2024-spring-cs466/">Rafael Oliveira, CS 466/666, Design and Analysis of Algorithms, Spring 2025</a></li></ul><h1 id="other">other</h1><ul><li><a href="https://homepages.cwi.nl/~monique/lnmb24/">Monique Laurent, Netherland, Networks and Semidefinite Programming, 2024</a>, <a href="https://homepages.cwi.nl/~lex/files/dict.pdf">Notes 1</a>, <a href="https://homepages.cwi.nl/~monique/lnmb24/lnmb20.pdf">Notes 2</a></li></ul><h1 id="lmi">LMI</h1><h2 id="matthew-m.-peet">Matthew M. Peet</h2><ul><li><a href="https://control.asu.edu/MAE509_frame.htm">MAE 509: LMI Methods in Optimal and Robust Control</a></li><li><a href="https://control.asu.edu/MiniCourse_frame.htm">PAUT54A1: MiniCourse on LMI and SOS Methods in Control</a></li><li><a href="https://control.asu.edu/MiniCourse_2019_frame.htm">MINICOURSE: LMI’s, SOS, and PDE’s</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SOS Programming 系列 - 0 预备知识和底层逻辑</title>
    <link href="/2025/12/12/02=SOS_Programming/SOS_0/"/>
    <url>/2025/12/12/02=SOS_Programming/SOS_0/</url>
    
    <content type="html"><![CDATA[<h1 id="sos-programming">SOS Programming</h1><hr><h2 id="what什么是-sossum-of-squares">1. What：什么是 SOS（Sum-of-Squares）</h2><h3 id="多项式非负性的一个可计算的充分条件">1.1 多项式非负性的一个“可计算的充分条件”</h3><p>在连续系统分析、鲁棒控制、非线性稳定性、优化中，经常需要证明一个多项式在某个集合上<strong>非负</strong>，例如 - Lyapunov 函数条件：<span class="math inline">\(V(x)\ge 0\)</span>、<span class="math inline">\(\dot V(x)\le 0\)</span> - 障碍函数（CBF）条件：<span class="math inline">\(h(x)\ge 0\)</span> 集合不变 - 多项式不等式约束：<span class="math inline">\(p(x)\ge 0\)</span></p><p>难点是：<strong>判定一个一般多项式在全空间（或半代数集合）非负，是很难的（一般是 NP-hard 级别）</strong>。SOS 的思想是：把“非负”替换成一个<strong>更强但可求解</strong>的条件。</p><hr><h3 id="sos-的定义">1.2 SOS 的定义</h3><p>给定一个实系数多项式 <span class="math inline">\(p(x)\)</span>（<span class="math inline">\(x\in\mathbb{R}^n\)</span>），如果存在一些多项式 <span class="math inline">\(f_i(x)\)</span> 使得</p><p><span class="math display">\[p(x)=\sum_{i=1}^m f_i(x)^2,\]</span></p><p>则称 <span class="math inline">\(p(x)\)</span> 是 <strong>Sum-of-Squares（SOS）多项式</strong>，记作 <span class="math inline">\(p(x)\in \Sigma[x]\)</span>。</p><p>显然： - 若 <span class="math inline">\(p(x)\)</span> 是 SOS，则 <span class="math inline">\(p(x)\ge 0\)</span> 对所有 <span class="math inline">\(x\)</span> 成立； - 反过来不一定（存在非负但不是 SOS 的多项式，维度/次数上去后会出现）。</p><p>因此 SOS 是“非负”的一个<strong>可计算的充分条件</strong>。</p><hr><h3 id="sos-与-gram-矩阵关键桥梁把多项式问题变成-psd-矩阵问题">1.3 SOS 与 Gram 矩阵（关键桥梁：把多项式问题变成 PSD 矩阵问题）</h3><p>设 <span class="math inline">\(p(x)\)</span> 的次数为 <span class="math inline">\(2d\)</span>（偶数，若是奇数也可通过引入松弛处理），取单项式向量 <span class="math inline">\(z(x)\)</span> 为所有次数 <span class="math inline">\(\le d\)</span> 的单项式（按某种顺序排列）：</p><p><span class="math display">\[z(x)=\big[1,\ x_1,\dots,\ x_n,\ x_1^2,\ x_1x_2,\dots,\ x_n^d\big]^\top.\]</span></p><p>核心定理（Gram 表示）： <span class="math display">\[p(x)\ \text{是 SOS} \quad \Longleftrightarrow \quad \exists\, Q\succeq 0\ \text{使得}\ p(x)=z(x)^\top Q z(x).\]</span></p><p>这里 <span class="math inline">\(Q\succeq 0\)</span> 表示 <span class="math inline">\(Q\)</span> 是<strong>半正定矩阵</strong>。</p><p>直观理解： - <span class="math inline">\(z^\top Q z\)</span> 展开后是一个多项式； - 约束 <span class="math inline">\(Q\succeq 0\)</span> 保证它可以写成若干平方和（因为 <span class="math inline">\(Q=R^\top R\)</span> 时 <span class="math inline">\(z^\top Q z=\|Rz\|^2\)</span>）。</p><p>这一步是 SOS programming 的“发动机”： - 多项式非负性（难） - 变成 PSD 矩阵可行性（SDP，可数值求解）</p><hr><h2 id="why为什么要用-sos">2. Why：为什么要用 SOS</h2><h3 id="真正想做的是验证合成sos-把它变成可求解的凸优化很多时候">2.1 真正想做的是“验证/合成”，SOS 把它变成可求解的凸优化（很多时候）</h3><p>控制里常见两类任务：</p><p><strong>(A) 验证（analysis）</strong><br>给定候选 <span class="math inline">\(V(x)\)</span>，验证： <span class="math display">\[V(x)-\epsilon\|x\|^{2d}\in \Sigma[x],\qquad -\dot V(x)\in \Sigma[x]\]</span> 用来证明稳定性、吸引域等。</p><p><strong>(B) 合成（synthesis）</strong><br>同时“找”一个多项式 <span class="math inline">\(V(x)\)</span>（甚至还要找控制律 <span class="math inline">\(u(x)\)</span>），使得上述条件成立。此时变量是 <span class="math inline">\(V\)</span> 的系数、控制律系数、以及 Gram 矩阵 <span class="math inline">\(Q\)</span> 等。</p><p>为什么 SOS 特别有价值： - 它把“解析证明”变成“可计算证明”； - 把很多原本非凸/不可判定的问题，替换为 SDP（或分层的 SDP 序列）。</p><hr><h3 id="sos-与半代数集合上的非负性putinar-证书在实际约束里会碰到">2.2 SOS 与半代数集合上的非负性：Putinar 证书（在实际约束里会碰到）</h3><p>很多时候不需要在全空间非负，而是在集合</p><p><span class="math display">\[\mathcal{K}=\{x:\ g_1(x)\ge 0,\dots,g_r(x)\ge 0\}\]</span></p><p>上非负（例如状态约束、吸引域估计的子水平集、CBF 安全集）。</p><p>常用的 SOS 证书形式（典型为 Putinar 型）是：</p><p><span class="math display">\[p(x)\ge 0\ \text{on}\ \mathcal{K}\ \Leftarrow\ p(x)=\sigma_0(x)+\sum_{i=1}^r \sigma_i(x)\,g_i(x),\quad \sigma_i(x)\in \Sigma[x].\]</span></p><p>解释： - <span class="math inline">\(\sigma_i(x)\ge 0\)</span>，<span class="math inline">\(g_i(x)\ge 0\)</span> 在集合内成立； - 因而右侧在集合内必然非负； - 通过“找 <span class="math inline">\(\sigma_i\)</span>”来构造一个<strong>可验证的非负证书</strong>。</p><p>这就是在 SOS Lyapunov、ROA、CBF、鲁棒性里反复看到的乘子（multiplier）逻辑。</p><hr><h3 id="现实代价sos-不是免费午餐">2.3 现实代价：SOS 不是“免费午餐”</h3><p>要清楚 SOS 的边界，否则很容易“跑通例子但不理解本质”：</p><ol type="1"><li><strong>保守性</strong>：非负不一定是 SOS；集合约束证书也需要一定条件（如 archimedean 条件）才有收敛保证。<br></li><li><strong>规模爆炸</strong>：<span class="math inline">\(z(x)\)</span> 的维度是组合数级别，SDP 变量 <span class="math inline">\(Q\)</span> 尺寸随 <span class="math inline">\(n,d\)</span> 急速增长。<br></li><li><strong>数值问题</strong>：SDP 的条件数、松弛项 <span class="math inline">\(\epsilon\)</span>、尺度缩放都会影响可解性与可信度。</li></ol><p>SOS programming，不是为了“把一切都扔进工具箱”，而是为了理解：<strong>它在什么结构下能高效地产生可信证书</strong>。</p><hr><h2 id="how怎么用-sos">3. How：怎么用 SOS</h2><h3 id="标准工作流">3.1 标准工作流</h3><ol type="1"><li><strong>把问题写成多项式不等式</strong>：稳定性、约束不变性、性能界等。<br></li><li><strong>选定证书结构</strong>：全局 SOS 或 半代数集合上的 SOS 乘子证书。<br></li><li><strong>选择次数（degree）</strong>：决定 <span class="math inline">\(V\)</span>、乘子 <span class="math inline">\(\sigma_i\)</span>、以及 <span class="math inline">\(z(x)\)</span> 的单项式上界。<br></li><li><strong>把“多项式等式”转为“系数匹配线性约束”</strong>：这是从符号到数值的关键一步。<br></li><li><strong>得到 SDP</strong>：变量是 Gram 矩阵（PSD）+ 多项式系数（线性）。<br></li><li><strong>调用 SDP 求解器</strong>：SeDuMi / SDPT3 / MOSEK 等。<br></li><li><strong>读回证书</strong>：得到 <span class="math inline">\(V(x)\)</span>、<span class="math inline">\(\sigma_i(x)\)</span> 或控制律系数，并做数值验证（采样检验、残差检验、尺度敏感性检验）。</li></ol><hr><h3 id="例-1lyapunov-稳定性验证最基础的-sos-用法">3.2 例 1：Lyapunov 稳定性验证（最基础的 SOS 用法）</h3><p>考虑多项式系统 <span class="math display">\[\dot x=f(x)\]</span> 给一个候选 <span class="math inline">\(V(x)\)</span>（多项式），希望证明原点渐近稳定。</p><p>常见 SOS 条件（加一个小的正定松弛）： <span class="math display">\[V(x)-\epsilon \|x\|^{2d} \in \Sigma[x],\qquad-\nabla V(x)^\top f(x) - \epsilon \|x\|^{2d} \in \Sigma[x].\]</span></p><p>含义： - 第一条：<span class="math inline">\(V\)</span> 正定（至少强制为 SOS 正定）； - 第二条：<span class="math inline">\(\dot V\le -\epsilon\|x\|^{2d}\)</span>，保证严格下降。</p><p>工具层面做的事情是：选择 <span class="math inline">\(V\)</span> 的形式/次数，然后把两个“属于 <span class="math inline">\(\Sigma[x]\)</span>”转成两个 PSD 约束。</p><hr><h3 id="例-2吸引域roa估计子水平集不变性">3.3 例 2：吸引域（ROA）估计：子水平集不变性</h3><p>想找到一个最大的 <span class="math inline">\(\rho\)</span>，使得集合 <span class="math display">\[\Omega_\rho=\{x:\ V(x)\le \rho\}\]</span> 在动力学下正不变，并且在集合内 <span class="math inline">\(\dot V&lt;0\)</span>。</p><p>经典 SOS 形式（S-procedure / 乘子）： <span class="math display">\[-(\nabla V^\top f)(x) - \sigma(x)\,(\rho - V(x)) \in \Sigma[x],\qquad \sigma(x)\in \Sigma[x].\]</span></p><p>解释： - 当 <span class="math inline">\(V(x)\le \rho\)</span> 时，<span class="math inline">\(\rho - V(x)\ge 0\)</span>； - 若 <span class="math inline">\(\sigma\ge 0\)</span>，则 <span class="math inline">\(\sigma(\rho-V)\)</span> 是非负项； - 上式保证在 <span class="math inline">\(V\le \rho\)</span> 内，<span class="math inline">\(-\dot V\)</span> 仍然非负，从而 <span class="math inline">\(\dot V\le 0\)</span>。</p><p>合成任务通常是最大化 <span class="math inline">\(\rho\)</span>（或相关体积近似指标），这会引入非凸性；实际常用交替迭代（fix <span class="math inline">\(V\)</span> solve <span class="math inline">\(\sigma,\rho\)</span>，再 fix <span class="math inline">\(\sigma\)</span> solve <span class="math inline">\(V\)</span> 等）。</p><hr><h3 id="例-3带约束的非负性把只在集合内成立转为-sos-证书">3.4 例 3：带约束的非负性：把“只在集合内成立”转为 SOS 证书</h3><p>若要保证 <span class="math display">\[p(x)\ge 0\quad \text{for all } x\in\mathcal{K}=\{x:g_i(x)\ge 0\},\]</span> 用乘子证书： <span class="math display">\[p(x)=\sigma_0(x)+\sum_i \sigma_i(x)g_i(x),\quad \sigma_i\in\Sigma[x].\]</span></p><p>应该把它理解为：<strong>在 <span class="math inline">\(\mathcal{K}\)</span> 上的非负性，被“解释”为全空间上的一个结构化分解。</strong> 工具不理解“集合上的逻辑”，它只理解“全空间的等式 + SOS/PSD 约束”。集合语义由通过乘子结构编码进去。</p><hr><h2 id="sos-tools-的底层求解逻辑与细节重点">4. SOS Tools 的“底层求解逻辑与细节”（重点）</h2><p>用 SOSTOOLS / YALMIP / Spotless / SumOfSquares.jl 时，看起来像“写几行就出结果”。但底层发生的事情基本都可以归结为下面这套机制。</p><hr><h3 id="关键抽象sos-约束-存在-psd-gram-矩阵-系数匹配">4.1 关键抽象：SOS 约束 = “存在 PSD Gram 矩阵 + 系数匹配”</h3><p>假设写了一个约束 <span class="math display">\[p(x)\in \Sigma[x].\]</span> 工具会做：</p><ol type="1"><li>选定 <span class="math inline">\(z(x)\)</span>（由指定次数上界决定）。<br></li><li>引入对称矩阵变量 <span class="math inline">\(Q\)</span>。<br></li><li>强制 <span class="math display">\[p(x)=z(x)^\top Q z(x)\]</span> 这不是数值点的等式，而是<strong>多项式恒等式</strong>。<br></li><li>把恒等式变成“系数匹配”：</li></ol><ul><li>将两边展开为单项式线性组合；</li><li>对每个单项式 <span class="math inline">\(x^\alpha\)</span>，匹配系数： <span class="math display">\[\text{coeff}_{x^\alpha}(p) = \text{coeff}_{x^\alpha}(z^\top Q z),\]</span> 得到一堆对 <span class="math inline">\(Q\)</span> 元素的<strong>线性等式约束</strong>。<br></li></ul><ol start="5" type="1"><li>再加上 PSD 约束： <span class="math display">\[Q\succeq 0.\]</span></li></ol><p>最终：SOS 约束变成了 SDP 约束。</p><hr><h3 id="为什么系数匹配是线性的">4.2 为什么“系数匹配”是线性的</h3><p><span class="math inline">\(z^\top Q z\)</span> 对 <span class="math inline">\(Q\)</span> 是线性的，因为 <span class="math display">\[z^\top Q z = \sum_{i,j} Q_{ij}\,z_i(x)\,z_j(x),\]</span> 其中 <span class="math inline">\(z_i z_j\)</span> 是已知的单项式（或多项式），未知量只有 <span class="math inline">\(Q_{ij}\)</span>，且是一阶出现，所以系数匹配给出线性方程组。</p><p>这也是为什么 SOS programming 大多落在 <strong>凸优化（SDP）</strong> 的范畴内：未知量只以线性方式进入，外加一个凸锥约束（PSD 锥）。</p><hr><h3 id="乘子multipliersos-的底层更多-gram-矩阵-更多线性约束">4.3 乘子（multiplier）SOS 的底层：更多 Gram 矩阵 + 更多线性约束</h3><p>当写 <span class="math display">\[p=\sigma_0+\sum_i \sigma_i g_i,\quad \sigma_i\in\Sigma[x],\]</span> 工具会： - 为每个 <span class="math inline">\(\sigma_i\)</span> 建一个 Gram 矩阵 <span class="math inline">\(Q_i\succeq 0\)</span>； - 将 <span class="math inline">\(\sigma_i(x)=z_i(x)^\top Q_i z_i(x)\)</span>； - 把 <span class="math inline">\(p - \sum_i \sigma_i g_i\)</span> 展开； - 对每个单项式做系数匹配，得到线性等式； - 合起来依然是 SDP。</p><p>因此应当把“复杂 SOS 证书”理解为： - PSD 变量（可能很多块） - 线性耦合约束（系数匹配把块耦合起来）</p><hr><h3 id="工具如何选择单项式基细节决定规模">4.4 工具如何“选择单项式基”——细节决定规模</h3><p>单项式向量 <span class="math inline">\(z(x)\)</span> 的长度决定 Gram 矩阵大小。</p><p>若 <span class="math inline">\(n\)</span> 变量、最高次数 <span class="math inline">\(d\)</span>，<span class="math inline">\(z\)</span> 的长度是组合数： <span class="math display">\[|z| = \binom{n+d}{d}.\]</span></p><p>Gram 矩阵 <span class="math inline">\(Q\)</span> 维度是 <span class="math inline">\(|z|\times |z|\)</span>，独立变量数量约为 <span class="math inline">\(|z|(|z|+1)/2\)</span>（对称）。</p><p>必须具备这种数量级直觉，否则会在“n=6, d=6”这类设置上直接爆炸。</p><hr><h3 id="sdp-求解器实际在做什么">4.5 SDP 求解器实际在做什么</h3><p>SOS 工具本身通常不“求解”，它只是把模型<strong>编译</strong>成标准 SDP 形式，然后交给 SDP 求解器。</p><p>标准 SDP（原始-对偶）形式可写成： <span class="math display">\[\begin{align}\min_x\ &amp; c^\top x\\\text{s.t. }&amp; F(x)=F_0+\sum_k x_k F_k \succeq 0,\\&amp; Ax=b.\end{align}\]</span></p><p>对应到 SOS： - <span class="math inline">\(x\)</span> 包括：Lyapunov/控制律/乘子多项式系数、以及 Gram 矩阵自由元素； - <span class="math inline">\(F(x)\succeq 0\)</span> 包括所有 Gram PSD 约束（可能是块对角）； - <span class="math inline">\(Ax=b\)</span> 就是系数匹配产生的线性等式。</p><p>大多数 SDP 求解器用<strong>内点法（primal-dual interior-point）</strong>，本质是不断求解一系列线性化的 KKT 系统，直到残差足够小。</p><p>需要知道的现实影响： 1) 规模越大，KKT 系统越大，时间/内存迅速上升；<br>2) 病态（尺度差、次数高、系数跨度大）会导致数值不稳定；<br>3) 很多“不可行”其实是数值不可行（tolerance 问题），不是数学上不可行。</p><hr><h3 id="求出来的-sos如何读回到平方和分解">4.6 “求出来的 SOS”如何读回到“平方和分解”</h3><p>如果得到 <span class="math inline">\(Q\succeq 0\)</span>，理论上可分解 <span class="math inline">\(Q=R^\top R\)</span>，于是 <span class="math display">\[p(x)=z^\top Q z = \|R z(x)\|^2 = \sum_i f_i(x)^2,\]</span> 其中 <span class="math inline">\(f_i\)</span> 是 <span class="math inline">\(Rz\)</span> 的各分量。</p><p>但实际工具常不显式给 <span class="math inline">\(f_i\)</span>，而只给 <span class="math inline">\(Q\)</span> 或多项式系数。 如果要“证书可展示”，可以： - 数值上做 Cholesky/特征分解拿到一个近似的平方和； - 或者只展示 SOS 约束满足与残差（更常见、更稳健）。</p><hr><h3 id="次数选择与双线性bilinearity">4.7 次数选择与双线性（Bilinearity）</h3><p>很多“合成”问题一旦同时优化多个多项式，会出现双线性项，典型如： - 同时求 <span class="math inline">\(V\)</span> 和 乘子 <span class="math inline">\(\sigma\)</span>：<span class="math inline">\(\sigma(\rho-V)\)</span> 中 <span class="math inline">\(\sigma\)</span> 与 <span class="math inline">\(V\)</span> 相乘； - 同时求 <span class="math inline">\(V\)</span> 和 控制律 <span class="math inline">\(u(x)\)</span>：<span class="math inline">\(\nabla V^\top g(x)u(x)\)</span> 中 <span class="math inline">\(V\)</span> 与 <span class="math inline">\(u\)</span> 相乘。</p><p>这会把 SDP 变成非凸问题（BMI 或 polynomial bilinear constraints）。 工具可能还能“跑”，但若不理解这一点，就会误以为“SOS 一定是凸的”。</p><p>工程上常见处理： - 固定一部分变量，解另一个 SDP； - 交替迭代（coordinate descent 风格）； - 或引入结构化参数化降低耦合。</p><hr><h2 id="如何让-sos-结果更可信更可扩展">5. 如何让 SOS 结果更可信、更可扩展</h2><ol type="1"><li><strong>先做验证再做合成</strong>：先给一个结构合理的 <span class="math inline">\(V\)</span> 验证稳定性，确认系统与尺度没问题，再谈合成。<br></li><li><strong>控制尺度</strong>：变量归一化，避免系数跨越过大；必要时加入 <span class="math inline">\(\epsilon\)</span> 松弛。<br></li><li><strong>从低次数开始</strong>：<span class="math inline">\(d=2\)</span>、<span class="math inline">\(d=3\)</span> 起步，逐步加；不要一开始就追求“更强证书”。<br></li><li><strong>残差检查</strong>：将求解后的 <span class="math inline">\(p(x)-z^\top Q z\)</span> 展开检查最大系数残差；对关键不等式做采样验证。<br></li><li><strong>明确保守性来源</strong>：是 SOS 放松导致，还是次数限制导致，还是集合证书结构限制导致。<br></li><li><strong>识别是否非凸</strong>：一旦同时优化多个多项式并出现乘积，别再把它当 SDP；要用迭代/固定策略。</li></ol><hr><h2 id="总结">6. 总结</h2><p>SOS programming 的核心不是“平方和”本身，而是这条链：</p><p><span class="math display">\[\begin{align*}\text{多项式非负性（难）} &amp;\Rightarrow \text{SOS 证书（充分条件）} \Rightarrow \\\text{Gram 矩阵 PSD + 系数匹配（SDP）}  &amp;\Rightarrow \text{数值求解 + 证书回读/验证}.\end{align*}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>SOS Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOS Tools</tag>
      
      <tag>optimization</tag>
      
      <tag>matlab</tag>
      
      <tag>SDP</tag>
      
      <tag>cvx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2 概念整理</title>
    <link href="/2025/04/29/00=Daily/4-L_2/"/>
    <url>/2025/04/29/00=Daily/4-L_2/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="一输入输出稳定性与增益约束-robot">一、输入输出稳定性与增益约束 <span class="github-emoji"><span>🤖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f916.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>输入输出系统被建模为一个算子 $ G $，将输入信号 <span class="math inline">\(u : {\mathbb R} \mapsto {\mathbb R}^m\)</span> 映射为输出信号 $ y : {R} ^p $，即 $ y = G(u)$。</p><p>输入输出信号被认为属于 $ {L}_q[0, ) $ 空间，该空间由满足：</p><p><span class="math display">\[\|f\|_q := \left( \int_0^{\infty} \|f(t)\|^q {\mathrm {d}}t \right)^{1/q} &lt; \infty\]</span></p><p>的测度函数构成。这一约束使我们关注信号整体能量而非瞬时行为。</p><p>输入输出映射的最基本要求是<strong>因果性</strong>（causality）：系统在时间 $ t $ 时刻的输出 $y(t) $ 不能依赖于未来的输入 $ u(s) &nbsp;(s &gt; t) $。数学上，映射 <span class="math inline">\(G : L_q \to L_p\)</span> 是因果的，当且仅当对任意 $ u,v _q $ 和任意 $ T &gt; 0 $，若</p><p><span class="math display">\[u(t) = v(t) \quad \forall t \in [0, T] ,\]</span></p><p>则有</p><p><span class="math display">\[(G(u))(t) = (G(v))(t), \quad \forall t \in [0, T].\]</span></p><p>这保证了系统对未来信息的不可预测性，是物理实现的基本要求。</p><p>在此基础上，若存在常数 $ &gt; 0 $，使得：</p><p><span class="math display">\[\|G(u)\|_q \leq \gamma \|u\|_q,\]</span></p><p>则系统被称为具有有限 $ {L}_q $-增益，该增益 $ $ 被称为系统的 ${L}_q $-增益。更进一步，若系统对任意有界输入 $ u _q $ 输出 $ y _q $，则称为 $ {L}_q $-stable。</p><hr><h2 id="二小增益定理与闭环稳定性-boom">二、小增益定理与闭环稳定性 <span class="github-emoji"><span>💥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>当两个系统 $ G_1, G_2 $ 以负反馈互联构成闭环系统时，其输入输出关系将变得复杂。系统互联后，扰动信号可能在环路中反复传播、放大或衰减，因此需要严密的准则判断系统整体的稳定性。若我们将系统互联结构建模为：</p><p><span class="math display">\[\begin{cases}y_1 = G_1(u_1), \quad u_1 = e_1 - y_2, \\y_2 = G_2(u_2), \quad u_2 = e_2 + y_1,\end{cases}\]</span></p><p>则可以通过替换得到：</p><p><span class="math display">\[u = e - FG(u), \quad y = G(u), \quad F = \begin{bmatrix}0 &amp; I \\-I &amp; 0\end{bmatrix}.\]</span></p><p>此时系统整体的闭环行为由非线性代数方程 $ u = (I + FG)^{-1} e $ 决定。映射 $ (e_1, e_2) (y_1, y_2) $ 是否定义良好（即闭环是否存在且唯一），并具有 $ {L}_q $-稳定性，成为关键问题。</p><p><strong>小增益定理</strong> 给出了这个问题的充分条件之一：</p><p>若两个因果系统 $ G_1, G_2 $ 分别具有有限 $ {L}_q $-增益 $ _1, _2 $，且满足：</p><p><span class="math display">\[\gamma_1 \cdot \gamma_2 &lt; 1,\]</span></p><p>则闭环系统整体是 $ {}_q $-稳定的，且映射 $ e y $ 是连续、唯一的。</p><p>这一定理以代数乘积揭示了稳定性的本质：在能量意义下，只要反馈回路的总“放大能力”小于1，就能保证系统“收敛”而不是发散。对于线性系统，这一结果直接对应于频域的 <span class="math inline">\(H_{\infty}\)</span> 范数约束；而对于非线性系统，小增益定理提供了从局部 Lipschitz 性或数值界估计出发的通用判据。</p><hr><h2 id="三无源性系统与能量守恒结构-mechanical_arm">三、无源性系统与能量守恒结构 <span class="github-emoji"><span>🦾</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f9be.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>相较于小增益定理的代数判据，无源性理论（passivity）从物理角度出发，刻画系统在能量传递上的性质。</p><p>一个系统是<strong>无源的</strong>，意味着它无法生成能量：系统输出给环境的能量不超过它从环境获取的能量。</p><p>形式上，若对系统 $ G $ 存在常数 $  $，对任意 $ u _2 $ 和任意时间 $ T &gt; 0 $，有：</p><p><span class="math display">\[\int_0^T \langle (G(u))(t), u(t) \rangle {\mathrm {d}}t \geq \beta,\]</span></p><p>则称 $G $ 为<strong>无源系统</strong>。进一步地，若存在 $ &gt; 0 $ 使得：</p><p><span class="math display">\[\int_0^T \langle (G(u))(t), u(t) \rangle {\mathrm{d}}t \geq \varepsilon \|G(u)\|_{\mathcal{L}_2[0,T]}^2 + \beta,\]</span></p><p>则称 $ G $ 为<strong>严格输出无源系统</strong>。</p><p>无源系统的结构性质具有深远影响。首先，它天然满足因果性；其次，两个无源系统的互联系统仍然无源，从而自动继承稳定性和有限增益性质。</p><p>更重要的是，严格输出无源系统必定具有有限 $ {L}_2 $-gain，其增益满足：</p><p><span class="math display">\[\|G(u)\|_{\mathcal{L}_2} \leq \frac{1}{\sqrt\varepsilon} \|u\|_{\mathcal{L}_2} ,\]</span></p><p>因此，无源性不仅是系统的物理属性，也是一种增益约束条件，为稳定性与性能分析提供了结构化的数学工具。</p><hr><h2 id="四耗散系统-person_fencing">四、耗散系统 <span class="github-emoji"><span>🤺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f93a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>为了将输入输出的增益性和状态空间的 Lyapunov 稳定性统一，提出了<strong>耗散系统</strong>的框架。</p><p>系统 $  = f(x, u), &nbsp;y = h(x, u) $ 被称为关于供能率 $ s(u, y) $ 的耗散系统，若存在函数 $ S(x)  $，称为<strong>存储函数</strong>，使得对任意时间区间 <span class="math inline">\([t_0, t_1]\)</span>：</p><p><span class="math display">\[S(x(t_1)) - S(x(t_0)) \le \int_{t_0}^{t_1} s(u(t), y(t)) {\mathrm{d}}t.\]</span></p><p>这一不等式意味着系统“吸收”的供能 $ s(u, y) $ 不会转化为比 $ S $ 所表示的内部能量更多的输出，换言之，系统具有某种“能量耗散”特性。</p><p>根据所选供能率 $ s(u,y) $ 的不同，可以刻画出不同的系统属性，如下分析。</p><h3 id="globe_with_meridians-4-1-供能率的选择与系统性能"><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 4-1 供能率的选择与系统性能</h3><p>耗散系统理论的核心，是通过定义一个输入输出对 $ (u, y) $ 上的<strong>供能率函数</strong> $ s(u, y) $，来描述系统的能量如何从输入传递到输出，以及是否会在系统内部以某种形式“被”存储或“耗散”。这一函数并非任意，而是根据我们对系统特性的不同关注点选出。典型的供能率如下：</p><h4 id="earth_africa-1.-su-y-uy"><span class="github-emoji"><span>🌍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 1. $ s(u, y) = u^y $</h4><p>此时，系统是无源的（Passive）。这是最自然的选择，反映系统从外界吸收的瞬时功率。此时，耗散不等式变为：</p><p><span class="math display">\[S(x(t_1)) - S(x(t_0)) \leq \int_{t_0}^{t_1} u^\top(t) y(t) {\mathrm {d}}t,\]</span></p><p>表示系统内部存储的能量增量不超过输入与输出之间的能量传递。其背后逻辑是：如果一个系统不会凭空生成能量，那它从输入吸收的功必须转化为内部能量或者输出能量。</p><p>在输入输出映射的形式下，该条件等价于：</p><p><span class="math display">\[\int_0^T u^\top(t) G(u)(t) {\mathrm {d}}t \geq \beta,\]</span></p><p>即映射 $ G $ 为无源系统。</p><h4 id="earth_africa-2.-su-y-uy---y2"><span class="github-emoji"><span>🌍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 2. $ s(u, y) = u^y - |y|^2 $</h4><p>此时，系统是<strong>严格输出无源的</strong>（Strict Output Passive）。在实际物理系统中，能量不仅被储存，还可能由于摩擦、电阻等原因被耗散。此时系统对输出信号的能量具有“惩罚项”，形式化为：</p><p><span class="math display">\[\int u^\top y \, {\mathrm {d}}t \geq \varepsilon \int \|y\|^2 {\mathrm {d}}t + \beta.\]</span></p><p>这说明系统输出越大，能量耗散越多。等价于：</p><p><span class="math display">\[\int_0^T u^\top(t) y(t) {\mathrm {d}}t - \varepsilon \int_0^T \|y(t)\|^2 {\mathrm {d}}t \geq \beta.\]</span></p><p>在无状态模型中，它等价于映射 $ G $ 满足：</p><p><span class="math display">\[\|G(u)\|_{\mathcal{L}_2}^2 \leq \frac{1}{\varepsilon} \int u^\top G(u) \, {\mathrm {d}}t.\]</span></p><p>因此，该供能率刻画的是<strong>输出能量耗散对输入功率的约束</strong>，其物理意义在于系统能从输出“泄露能量”。</p><h4 id="earth_africa-3.-su-y-2-u2---y2"><span class="github-emoji"><span>🌍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 3. $ s(u, y) =  ^2 |u|^2 -  |y|^2 $</h4><p>此时，系统具有有限 $ {L}_2 $-增益，不超过 $ $。该形式直接对应于系统从输入信号到输出信号的<strong>增益控制</strong>。若存在存储函数 $ S(x) $ 使得：</p><p><span class="math display">\[S(x(t_1)) - S(x(t_0)) \leq \int_{t_0}^{t_1} \left( \frac{1}{2} \gamma^2 \|u(t)\|^2 - \|y(t)\|^2 \right) {\mathrm {d}}t,\]</span></p><p>则可推出：</p><p><span class="math display">\[\|y\|^2_{\mathcal{L}_2} \leq \gamma^2 \|u\|^2_{\mathcal{L}_2} + 2 S(x_0),\]</span></p><p>这说明系统的输出能量不会超过输入能量的 $ ^2 $ 倍，加上初始能量的一个常数项。若 $ S(x) = 0 $，这就成了标准的 $ {L}_2 $-增益界定。</p><h4 id="earth_africa-4.-su-y--y2"><span class="github-emoji"><span>🌍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 4. $ s(u, y) = -|y|^2 $</h4><p>此时，系统输出能量呈现衰减趋势。这是一个强约束：系统的能量<strong>不但不能增加</strong>，甚至其输出总能量<strong>必须“亏损”</strong>。从不等式：</p><p><span class="math display">\[S(x(t_1)) - S(x(t_0)) \leq - \int_{t_0}^{t_1} \|y(t)\|^2 {\mathrm{d}}t,\]</span></p><p>可知只要输出有能量，存储函数必然下降。这是某些无源耗散系统（如阻尼结构）的典型模型，表明系统必须将输出转化为内部的损耗耗散，直至最终达到稳定。</p><h4 id="earth_africa-5.-su-y-y2---2-u2"><span class="github-emoji"><span>🌍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 5. $ s(u, y) = |y|^2 - {}^2 |u|^2 $</h4><p>此时，系统放大能力有限，适用于构造 <span class="math inline">\(H_{\infty}\)</span> 控制目标。这是一种对偶形式，更倾向于用于性能评估。若系统关于该 $ s(u, y) $ 是耗散的，则必然满足：</p><p><span class="math display">\[\int \|y\|^2 {\mathrm {d}}t \leq \gamma^2 \int \|u\|^2 {\mathrm {d}}t + S(x_0),\]</span></p><p>进而推出增益约束：</p><p><span class="math display">\[\|y\|_{\mathcal{L}_2} \leq \gamma \|u\|_{\mathcal{L}_2}.\]</span></p><p>它是最直接的 <span class="math inline">\(H_{\infty}\)</span> 范数定义形式，用作控制设计中的目标函数。该供能率的优势在于它对输出信号进行直接约束，适用于性能评估（如抗扰动、最坏场景最小化等场景）。</p><h3 id="globe_with_meridians4-2-available-storage"><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>4-2 available storage</h3><p><strong>定义：</strong></p><p><span class="math display">\[S_a(x) := \sup_{u \in {\mathcal L}_2} \left\{ - \int_0^\infty s(u(t), y(t)) {\mathrm {d}}t \right\}, \quad x(0) = x.\]</span></p><p>该函数描述从当前状态 $ x $ 出发，系统在所有可行输入作用下，<strong>所能向外界“释放”的最大能量</strong>。其物理含义与热力学中的“可用能”相同，表明状态 $ x $ 所蕴含的“控制势能”极限。</p><p><strong>从控制意义看：</strong></p><ul><li>若 $ S_a(x) = 0 $，说明此状态下系统无法向外界输出能量，是耗尽状态；</li><li>若 $ S_a(x) &gt; 0 $，说明存在输入使系统输出净能量，状态具有能量转换能力。</li></ul><p><strong>数学上，available storage 还有如下性质：</strong></p><ul><li>它是所有存储函数的<strong>下界</strong>，即：若 $ S(x) $ 是任意使系统耗散的函数，则：</li></ul><p><span class="math display">\[S_a(x) \leq S(x), \quad \forall x.\]</span></p><ul><li>它自身就是一个存储函数；</li><li>在 passivity 条件下，$ s(u, y) = u^y $，可得：</li></ul><p><span class="math display">\[\int_0^T u^\top y \, {\mathrm {d}}t \geq -S_a(x(0)).\]</span></p><p>这为系统耗散性提供了<strong>最小能量约束</strong>，有助于进行能量一致性判断与系统设计下界估计。</p><hr><h2 id="五h_infty-控制问题-mag">五、<span class="math inline">\(H_{\infty}\)</span> 控制问题 <span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>考虑非线性系统：</p><p><span class="math display">\[\dot{x} = f(x) + g(x) u + k(x) d,\]</span></p><p>其中：<span class="math inline">\(x \in \mathbb{R}^n\)</span>：系统状态；<span class="math inline">\(u \in \mathbb{R}^{n_u}\)</span>：控制输入；<span class="math inline">\(d \in \mathbb{R}^{n_d}\)</span>：外部扰动；<span class="math inline">\(f(x), g(x), k(x)\)</span> 为局部 Lipschitz 连续函数。</p><p>系统的性能输出定义为：</p><p><span class="math display">\[z(x, u) = Q(x) + u^\top R u,\]</span></p><p>其中 <span class="math inline">\(Q(x) \geq 0\)</span> 是正定函数，<span class="math inline">\(R \succ 0\)</span> 是控制输入的权重矩阵。性能目标为：对于任意扰动 <span class="math inline">\(d \in \mathcal{L}_2\)</span>，闭环系统满足：</p><p><span class="math display">\[\int_0^\infty \left( Q(x(t)) + u^\top(t) R u(t) \right) {\mathrm {d}}t \leq \gamma^2 \|d\|^2_{\mathcal{L}_2}.\]</span></p><p>这是一种标准的非线性 <span class="math inline">\(H_\infty\)</span> 控制形式，目标是以最小控制代价抑制最强扰动。</p><h3 id="bulb-5-1.-耗散系统-h_infty-性能指标"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 5-1. 耗散系统 <span class="math inline">\(H_\infty\)</span> 性能指标</h3><p>构造供能率函数：</p><p><span class="math display">\[s(d, x, u) := Q(x) + u^\top R u - \gamma^2 \|d\|^2,\]</span></p><p>若存在光滑非负函数 <span class="math inline">\(V(x)\)</span> 使得系统沿解轨迹满足：</p><p><span class="math display">\[\dot{V}(x) \leq - s(d, x, u) ,\]</span></p><p>则沿系统轨迹有</p><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t} V(x(t))\le -Q(x) - u^\top R u + \gamma^2 \|d\|^2.\]</span></p><p>则通过积分可得：</p><p><span class="math display">\[V(x(0)) \geq \int_0^\infty \left( Q(x(t)) + u^\top(t) R u(t) \right) {\mathrm {d}}t - \gamma^2 \|d\|^2_{\mathcal{L}_2},\]</span></p><p>即系统满足期望的 <span class="math inline">\(H_\infty\)</span> 性能指标。</p><h3 id="bulb-5-2.-hji-推导"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 5-2. HJI 推导</h3><p>考虑沿系统轨迹对 <span class="math inline">\(V(x)\)</span> 求导：</p><p><span class="math display">\[\dot{V}(x) = \nabla V(x)^\top \left( f(x) + g(x) u + k(x) d \right).\]</span></p><p>代入上述不等式，有：</p><p><span class="math display">\[\nabla V^\top f(x) + \nabla V^\top g(x) u + \nabla V^\top k(x) d \leq - Q(x) - u^\top R u + \gamma^2 \|d\|^2.\]</span></p><p>整理后构造 Hamiltonian：</p><p><span class="math display">\[H(x, \nabla V, u, d) := \nabla V^\top f(x) + Q(x) + \nabla V^\top g(x) u + u^\top R u + \nabla V^\top k(x) d - \gamma^2 \|d\|^2.\]</span></p><p>要求：</p><p><span class="math display">\[\inf_{u} \sup_{d} H(x, \nabla V, u, d) \leq 0,\]</span></p><p>即系统在最坏扰动下依然满足性能限制。</p><h3 id="bulb-5-3.-扰动与控制的最优化"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 5-3. 扰动与控制的最优化</h3><ul><li><strong>(1) 对扰动 <span class="math inline">\(d\)</span> 的极大化（扰动 <span class="math inline">\(d\)</span> 试图最大化供能）</strong>：</li></ul><p>求：</p><p><span class="math display">\[\sup_d \left\{ \nabla V^\top k(x) d - \gamma^2 \|d\|^2 \right\}\]</span></p><p>最优扰动为：</p><p><span class="math display">\[d^* = \frac{1}{2\gamma^2} k(x)^\top \nabla V(x)\]</span></p><p>对应最大值为：</p><p><span class="math display">\[\frac{1}{4\gamma^2} \| \nabla V^\top k(x) \|^2.\]</span></p><ul><li><strong>(2) 对控制输入 <span class="math inline">\(u\)</span> 的极小化（控制 <span class="math inline">\(u\)</span> 试图最小化供能）</strong>：</li></ul><p>求：</p><p><span class="math display">\[\inf _u \left\{ \nabla V^\top g(x) u + u^\top R u \right\} \]</span></p><p>最优控制为：</p><p><span class="math display">\[u^* = - \frac{1}{2} R^{-1} g(x)^\top \nabla V(x)\]</span></p><p>对应最小值为：</p><p><span class="math display">\[ -\frac{1}{4} \nabla V^\top g(x) R^{-1} g(x)^\top \nabla V.\]</span></p><p>最优控制为：</p><p><span class="math display">\[u^* = - \frac{1}{2} R^{-1} g(x)^\top \nabla V(x)\]</span></p><p>对应最小值为：</p><p><span class="math display">\[ -\frac{1}{4} \nabla V^\top g(x) R^{-1} g(x)^\top \nabla V.\]</span></p><h3 id="bulb-5-4.-hji-不等式最终形式"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 5-4. HJI 不等式最终形式</h3><p>将控制项与扰动项代入 Hamiltonian，得到最终形式的 HJI 不等式：</p><p><span class="math display">\[\nabla V^\top f(x) + Q(x) - \frac{1}{4} \nabla V^\top g(x) R^{-1} g(x)^\top \nabla V + \frac{1}{4\gamma^2} \|\nabla V^\top k(x)\|^2 \leq 0.\]</span></p><p>若存在正定光滑函数 <span class="math inline">\(V(x)\)</span> 满足上述不等式，则控制器：</p><p><span class="math display">\[u(x) = -\frac{1}{2} R^{-1} g(x)^\top \nabla V(x)\]</span></p><p>确保系统满足性能约束：</p><p><span class="math display">\[\int_0^\infty \left( Q(x(t)) + u^\top(t) R u(t) \right) dt \leq \gamma^2 \|d\|^2_{\mathcal{L}_2}.\]</span></p><hr>]]></content>
    
    
    <categories>
      
      <category>control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>耗散系统</tag>
      
      <tag>L2</tag>
      
      <tag>H_infty control</tag>
      
      <tag>HJI</tag>
      
      <tag>Robust control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github 端口连接</title>
    <link href="/2025/03/27/00=Daily/3-git_port/"/>
    <url>/2025/03/27/00=Daily/3-git_port/</url>
    
    <content type="html"><![CDATA[<h2 id="rocket-一问题描述"><span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 一、问题描述</h2><p>以前从本地 <code>pull/push</code> 文件向 <code>github</code> 仓库远程操作时，没有任何问题，今天操作出现如下报错： </p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">bash<br>$ git pull<br>ssh: <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> host github.com port <span class="hljs-number">22</span>: <span class="hljs-keyword">Connection</span> refused<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">from</span> remote repository.<br>​<br>Please make sure you have the correct <span class="hljs-keyword">access</span> rights<br><span class="hljs-keyword">and</span> the repository <span class="hljs-keyword">exists</span>.<br></code></pre></td></tr></tbody></table></figure> 提示链接 <code>github</code> 的 <code>22</code> 端口被拒绝。<p></p><h2 id="zap-二解决方案"><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 二、解决方案</h2><ul><li>修改 <code>SSH</code> 的 <code>config</code> 文件。在 <code>C:\Users\用户名\.ssh</code> 目录下，新建一个名为 <code>config</code> 的文件，内容如下：（如果目录下有 <code>config</code> 文件，直接在文件里添加即可） <figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Host github<span class="hljs-selector-class">.com</span><br>  HostName github<span class="hljs-selector-class">.com</span><br>  Port <span class="hljs-number">443</span><br></code></pre></td></tr></tbody></table></figure> 切换端口为<code>443</code>。</li><li>打开 <code>Git Bash</code>，输入以下命令，测试连接： <figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></tbody></table></figure></li><li>如果连接成功，会显示以下信息： <figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi username! You<span class="hljs-symbol">'ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></tbody></table></figure></li><li>重新 <code>pull/push</code> 即可。</li></ul><h2 id="dart-三报错原因"><span class="github-emoji"><span>🎯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3af.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 三、报错原因</h2><ul><li>可能是因为 <code>SSH</code> 的 <code>config</code> 文件中配置的端口与实际使用的端口不一致。</li><li>用了 <code>VPN</code> 导致的网络配置问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS code 编译 .tex 文件</title>
    <link href="/2025/03/04/00=Daily/2-vs_tex/"/>
    <url>/2025/03/04/00=Daily/2-vs_tex/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-vs-code-插件latex-workshop">1. 安装 VS code 插件：<code>Latex Workshop</code></h2><p><span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在 VS code 扩展商店中找到 <a href="https://github.com/James-Yu/LaTeX-Workshop/wiki/Compile#placeholders">Latex Workshop</a> 插件（如下），安装即可。 <img src="/img/VSTeX/LatexWorkshop.jpg" alt="LatexWorkshop"></p><h2 id="打开一个-.tex-文件">2. 打开一个 <code>.tex</code> 文件</h2><p><span class="github-emoji"><span>🤖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f916.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 可以看到 VS code 已经自动高亮文档内容 <img src="/img/VSTeX/latex.jpg" alt="latex"></p><h2 id="配置-latex-workshop">3. 配置 Latex Workshop</h2><ul><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 按 <code>F1</code>，搜索<code>setjson</code>，打开配置文件 <img src="/img/VSTeX/setjson.jpg" alt="setjson"></li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 可以看到在项目中生成了<code>.vscode</code>文件夹，在其中打开<code>settings.json</code>文件，添加如下代码： <figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs autoit">{<br>    <span class="hljs-string">"latex-workshop.latex.autoBuild.run"</span>: <span class="hljs-string">"never"</span>,        <span class="hljs-meta"># 从不自动编译</span><br>    <span class="hljs-string">"latex-workshop.showContextMenu"</span>: <span class="hljs-literal">true</span>,               <span class="hljs-meta"># 显示右键菜单，出现<span class="hljs-string">"Build Latex Project"</span>选项</span><br>    <span class="hljs-string">"latex-workshop.intellisense.package.enabled"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-meta"># 启用包自动完成</span><br>    <span class="hljs-string">"latex-workshop.message.error.show"</span>: <span class="hljs-literal">false</span>,           <span class="hljs-meta"># 不显示错误信息（从终端获取）</span><br>    <span class="hljs-string">"latex-workshop.message.warning.show"</span>: <span class="hljs-literal">false</span>,         <span class="hljs-meta"># 不显示警告信息（从终端获取）</span><br>    <span class="hljs-string">"latex-workshop.latex.tools"</span>: [<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"xelatex"</span>,<br>            <span class="hljs-string">"command"</span>: <span class="hljs-string">"xelatex"</span>,<br>            <span class="hljs-string">"args"</span>: [<br>                <span class="hljs-string">"-synctex=1"</span>,<br>                <span class="hljs-string">"-interaction=nonstopmode"</span>,<br>                <span class="hljs-string">"-file-line-error"</span>,<br>                <span class="hljs-string">"%DOCFILE%"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"pdflatex"</span>,<br>            <span class="hljs-string">"command"</span>: <span class="hljs-string">"pdflatex"</span>,<br>            <span class="hljs-string">"args"</span>: [<br>                <span class="hljs-string">"-synctex=1"</span>,<br>                <span class="hljs-string">"-interaction=nonstopmode"</span>,<br>                <span class="hljs-string">"-file-line-error"</span>,<br>                <span class="hljs-string">"%DOCFILE%"</span>                                <span class="hljs-meta"># 文件所在路径可以为中文，若为<span class="hljs-string">"%DOC"</span>则不可有中文</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"latexmk"</span>,<br>            <span class="hljs-string">"command"</span>: <span class="hljs-string">"latexmk"</span>,<br>            <span class="hljs-string">"args"</span>: [<br>                <span class="hljs-string">"-synctex=1"</span>,<br>                <span class="hljs-string">"-interaction=nonstopmode"</span>,<br>                <span class="hljs-string">"-file-line-error"</span>,<br>                <span class="hljs-string">"-pdf"</span>,<br>                <span class="hljs-string">"-outdir=%OUTDIR%"</span>,<br>                <span class="hljs-string">"%DOCFILE%"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"bibtex"</span>,<br>            <span class="hljs-string">"command"</span>: <span class="hljs-string">"bibtex"</span>,<br>            <span class="hljs-string">"args"</span>: [<br>                <span class="hljs-string">"%DOCFILE%"</span><br>            ]<br>        }<br>    ],<br>    <span class="hljs-string">"latex-workshop.latex.recipes"</span>: [<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"XeLaTeX"</span>,<br>            <span class="hljs-string">"tools"</span>: [<br>                <span class="hljs-string">"xelatex"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"PDFLaTeX"</span>,<br>            <span class="hljs-string">"tools"</span>: [<br>                <span class="hljs-string">"pdflatex"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"BibTeX"</span>,<br>            <span class="hljs-string">"tools"</span>: [<br>                <span class="hljs-string">"bibtex"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"LaTeXmk"</span>,<br>            <span class="hljs-string">"tools"</span>: [<br>                <span class="hljs-string">"latexmk"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"xelatex -&gt; bibtex -&gt; xelatex*2"</span>,<br>            <span class="hljs-string">"tools"</span>: [<br>                <span class="hljs-string">"xelatex"</span>,<br>                <span class="hljs-string">"bibtex"</span>,<br>                <span class="hljs-string">"xelatex"</span>,<br>                <span class="hljs-string">"xelatex"</span><br>            ]<br>        },<br>        {<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"pdflatex -&gt; bibtex -&gt; pdflatex*2"</span>,<br>            <span class="hljs-string">"tools"</span>: [<br>                <span class="hljs-string">"pdflatex"</span>,<br>                <span class="hljs-string">"bibtex"</span>,<br>                <span class="hljs-string">"pdflatex"</span>,<br>                <span class="hljs-string">"pdflatex"</span><br>            ]<br>        },<br>    ],<br>    <span class="hljs-string">"latex-workshop.latex.clean.fileTypes"</span>: [<br>        <span class="hljs-string">"*.aux"</span>,<br>        <span class="hljs-string">"*.bbl"</span>,<br>        <span class="hljs-string">"*.blg"</span>,<br>        <span class="hljs-string">"*.idx"</span>,<br>        <span class="hljs-string">"*.ind"</span>,<br>        <span class="hljs-string">"*.lof"</span>,<br>        <span class="hljs-string">"*.lot"</span>,<br>        <span class="hljs-string">"*.out"</span>,<br>        <span class="hljs-string">"*.toc"</span>,<br>        <span class="hljs-string">"*.acn"</span>,<br>        <span class="hljs-string">"*.acr"</span>,<br>        <span class="hljs-string">"*.alg"</span>,<br>        <span class="hljs-string">"*.glg"</span>,<br>        <span class="hljs-string">"*.glo"</span>,<br>        <span class="hljs-string">"*.gls"</span>,<br>        <span class="hljs-string">"*.ist"</span>,<br>        <span class="hljs-string">"*.fls"</span>,<br>        <span class="hljs-string">"*.log"</span>,<br>        <span class="hljs-string">"*.fdb_latexmk"</span><br>    ],<br>    <span class="hljs-string">"latex-workshop.latex.autoClean.run"</span>: <span class="hljs-string">"onFailed"</span>,                       <span class="hljs-meta"># 编译失败时自动清理上述类型的辅助文件（<span class="hljs-string">"OnBuilt"</span>:无论编译是否成功，都清除辅助文件；<span class="hljs-string">"never"</span>:无论编译是否成功，都不清除）</span><br>    <span class="hljs-string">"latex-workshop.latex.recipe.default"</span>: <span class="hljs-string">"lastUsed"</span>,                      <span class="hljs-meta"># 编译时使用上次使用的编译方式</span><br>    <span class="hljs-string">"latex-workshop.view.pdf.internal.synctex.keybinding"</span>: <span class="hljs-string">"double-click"</span>   <span class="hljs-meta"># 点击 pdf 可以跳转到相应代码位置</span><br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="设置编译快捷键可选">4. 设置编译快捷键（可选）</h2><ul><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 左下角打开设置 -&gt; <code>Keyboard Shortcut</code>-&gt; 搜索<code>recipe</code> -&gt; 双击中间的<code>When</code> -&gt; 按下想要使用的快捷键</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 选择编译方式 <img src="/img/VSTeX/compile.jpg" alt="compile"></li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>直接运行<code>.tex</code>文件也可以编译</strong></li></ul><h2 id="测试">5. 测试</h2><figure><img src="/img/VSTeX/test.jpg" alt="test"><figcaption aria-hidden="true">test</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Latex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS code</tag>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是 .bat 文件？</title>
    <link href="/2025/03/03/00=Daily/1-bat_explain/"/>
    <url>/2025/03/03/00=Daily/1-bat_explain/</url>
    
    <content type="html"><![CDATA[<h2 id="monocle_face-what-is-the-file-with-the-suffix-.bat"><span class="github-emoji"><span>🧐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f9d0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> What is the file with the suffix “.bat” ?</h2><ul><li>后缀为“.bat”的文档是一个批处理文件。它是一种<strong>可执行</strong>文件，其中包含由操作系统执行的一系列命令。批处理文件通常用于自动化涉及多个命令的任务。它们通常用于<strong>安装</strong>软件、<strong>配置</strong>系统设置或<strong>执行</strong>其他需要多个步骤的任务。</li></ul><h2 id="rocket-example"><span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Example</h2><p><strong>这是一个批处理文件的示例，它将“open with VS code”选项添加到Windows右键菜单中，允许用户直接右键单击文件夹或其背景（空白），并在 VS code 中打开文件夹。</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">@echo off<br>REG ADD <span class="hljs-string">"HKEY_CLASSES_ROOT<span class="hljs-char escape_">\D</span>irectory<span class="hljs-char escape_">\B</span>ackground<span class="hljs-char escape_">\s</span>hell<span class="hljs-char escape_">\O</span>pen with VS Code"</span> <span class="hljs-symbol">/ve</span> <span class="hljs-symbol">/t</span> REG_SZ <span class="hljs-symbol">/d</span> <span class="hljs-string">"open here with VS Code"</span> <span class="hljs-symbol">/f</span><br>REG ADD <span class="hljs-string">"HKEY_CLASSES_ROOT<span class="hljs-char escape_">\D</span>irectory<span class="hljs-char escape_">\B</span>ackground<span class="hljs-char escape_">\s</span>hell<span class="hljs-char escape_">\O</span>pen with VS Code<span class="hljs-char escape_">\c</span>ommand"</span> <span class="hljs-symbol">/ve</span> <span class="hljs-symbol">/t</span> REG_SZ <span class="hljs-symbol">/d</span> <span class="hljs-string">"<span class="hljs-char escape_">\"</span>E:<span class="hljs-char escape_">\V</span>S code<span class="hljs-char escape_">\M</span>icrosoft VS Code<span class="hljs-char escape_">\C</span>ode.exe<span class="hljs-char escape_">\"</span> <span class="hljs-char escape_">\"</span>%%V<span class="hljs-char escape_">\"</span>"</span> <span class="hljs-symbol">/f</span><br>echo VS Code Successful！<br>pause<br></code></pre></td></tr></tbody></table></figure><ul><li><span class="github-emoji"><span>📞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4de.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>@echo off</code></strong> 上述代码的第一行<strong>关闭</strong>命令行窗口的响应，以防止每次<strong>执行命令</strong>时它出现在屏幕上，使界面更清晰。<p style="margin-bottom:40px;"></p></li><li><span class="github-emoji"><span>🖥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f5a5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>REG ADD "HKEY_CLASSES_ROOT\Directory\Background\shell\Open with VS Code" /ve /t REG_SZ /d "open here with VS Code" /f</code></strong> 将键或值添加到Windows注册表。<ul><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>KEY_CLASSES_ROOT\Directory\Background\shell\Open with VS Code</code></strong> : 在Windows资源管理器的右键菜单中创建一个新选项“open with VS code”。</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>/ve</code></strong> : 创建一个默认值（未命名键值）。</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>/t REG_SZ</code></strong> : 将值的数据类型设置为<strong>REG_SZ</strong>（<em>字符串</em>）。</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>/d "open here with VS Code"</code></strong> : 设置注册表的值，即右键菜单中显示的文本（<strong>open here with VS code</strong>）。</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>/f</code></strong> : 强制操作<strong>覆盖</strong>任何现有键或值。<p style="margin-bottom:40px;"></p></li></ul></li><li><span class="github-emoji"><span>🖥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f5a5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>REG ADD "HKEY_CLASSES_ROOT\Directory\Background\shell\Open with VS Code\command" /ve /t REG_SZ /d "\"E:\VS code\Microsoft VS Code\Code.exe\" \"%%V\"" /f</code></strong><ul><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>HKEY_CLASSES_ROOT\Directory\Background\shell\Open with VS Code\command</code></strong>: 定义单击菜单项后要执行的命令。</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>"E:\VS code\Microsoft VS Code\Code.exe"</code></strong>: VS code 的可执行文件路径。</li><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>"%%V"</code></strong>: <strong>当前</strong>文件夹路径，即用户右键单击的文件夹。<p style="margin-bottom:40px;"></p></li></ul></li><li><span class="github-emoji"><span>🖥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f5a5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><code>echo VS Code Successful！</code></strong><ul><li><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在命令行窗口中显示提示，表明注册表已成功修改。</li></ul></li></ul><h2 id="file_folder-operation-effect"><span class="github-emoji"><span>📁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Operation effect</h2><ul><li><span class="github-emoji"><span>👆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f446.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Right-click the folder or blank space inside the folder, select “Open with VS Code”. <img src="/img/BatExplain/operation1.jpg" alt="right-click1"> <img src="/img/BatExplain/operation2.jpg" alt="right-click2"></li></ul>]]></content>
    
    
    <categories>
      
      <category>VS code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS code</tag>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
